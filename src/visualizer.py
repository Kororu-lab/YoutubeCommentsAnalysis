"""
Visualizer Module
ÏãúÍ∞ÅÌôî Î™®Îìà
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.font_manager as fm
import seaborn as sns
from matplotlib import rcParams
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import logging
from typing import Dict, List, Tuple, Optional
import os
from datetime import datetime

# ÏõåÎìúÌÅ¥ÎùºÏö∞Îìú
from wordcloud import WordCloud
import networkx as nx
from collections import Counter

# ÌïúÍµ≠Ïñ¥ Ìè∞Ìä∏ ÏÑ§Ï†ï
import platform

class Visualizer:
    """ÏãúÍ∞ÅÌôî ÌÅ¥ÎûòÏä§"""
    
    def __init__(self, config):
        """
        Ï¥àÍ∏∞Ìôî
        Args:
            config: AnalysisConfig Í∞ùÏ≤¥
        """
        self.config = config
        self.logger = self._setup_logger()
        self.output_dir = config.OUTPUT_STRUCTURE['visualizations']
        
        # ÌïúÍµ≠Ïñ¥ Ìè∞Ìä∏ ÏÑ§Ï†ï
        self._setup_korean_font()
        
        # ÏãúÍ∞ÅÌôî Ïä§ÌÉÄÏùº ÏÑ§Ï†ï
        self._setup_style()
    
    def _setup_logger(self):
        """Î°úÍ±∞ ÏÑ§Ï†ï"""
        logger = logging.getLogger(__name__)
        logger.setLevel(getattr(logging, self.config.LOGGING['level']))
        
        if not logger.handlers:
            handler = logging.FileHandler(self.config.LOGGING['file'], encoding='utf-8')
            formatter = logging.Formatter(self.config.LOGGING['format'])
            handler.setFormatter(formatter)
            logger.addHandler(handler)
            
        return logger
    
    def _setup_korean_font(self):
        """Í∞ïÌôîÎêú ÌïúÍ∏Ä Ìè∞Ìä∏ ÏÑ§Ï†ï"""
        try:
            import matplotlib.font_manager as fm
            
            # ÏãúÏä§ÌÖúÎ≥Ñ ÌïúÍ∏Ä Ìè∞Ìä∏ Ï∞æÍ∏∞
            korean_fonts = []
            system = platform.system()
            
            if system == "Darwin":  # macOS
                korean_fonts = [
                    "AppleGothic", "Apple SD Gothic Neo", "Noto Sans CJK KR", 
                    "Malgun Gothic", "NanumGothic", "Arial Unicode MS"
                ]
            elif system == "Windows":
                korean_fonts = [
                    "Malgun Gothic", "NanumGothic", "Gulim", "Dotum", 
                    "Batang", "Gungsuh", "Arial Unicode MS"
                ]
            else:  # Linux
                korean_fonts = [
                    "Noto Sans CJK KR", "NanumGothic", "UnDotum", 
                    "Baekmuk Gulim", "Arial Unicode MS"
                ]
            
            # ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Ìè∞Ìä∏ Ï∞æÍ∏∞
            available_fonts = [f.name for f in fm.fontManager.ttflist]
            found_font = None
            found_font_path = None
            
            for font in korean_fonts:
                if font in available_fonts:
                    found_font = font
                    # Ìè∞Ìä∏ Í≤ΩÎ°ú Ï∞æÍ∏∞
                    for font_obj in fm.fontManager.ttflist:
                        if font_obj.name == font and font_obj.fname.endswith('.ttf'):
                            found_font_path = font_obj.fname
                            break
                    break
            
            if found_font:
                self.korean_font_name = found_font
                self.korean_font_path = found_font_path
                
                # matplotlib ÏÑ§Ï†ï
                rcParams['font.family'] = found_font
                rcParams['font.sans-serif'] = [found_font] + ['DejaVu Sans', 'Arial']
                rcParams['axes.unicode_minus'] = False
                rcParams['font.size'] = 12
                
                # plt.rcParamsÎèÑ ÎèôÏãú ÏóÖÎç∞Ïù¥Ìä∏
                plt.rcParams['font.family'] = found_font
                plt.rcParams['font.sans-serif'] = [found_font] + ['DejaVu Sans', 'Arial']
                plt.rcParams['axes.unicode_minus'] = False
                plt.rcParams['font.size'] = 12
                
                self.logger.info(f"‚úÖ ÌïúÍ∏Ä Ìè∞Ìä∏ ÏÑ§Ï†ï ÏôÑÎ£å: {found_font} ({found_font_path})")
            else:
                # Ìè¥Î∞±: Í∏∞Î≥∏ Ìè∞Ìä∏ ÏÇ¨Ïö©
                self.korean_font_name = "DejaVu Sans"
                self.korean_font_path = None
                
                rcParams['font.family'] = 'DejaVu Sans'
                rcParams['font.sans-serif'] = ['DejaVu Sans', 'Arial', 'Liberation Sans']
                rcParams['axes.unicode_minus'] = False
                rcParams['font.size'] = 12
                
                plt.rcParams['font.family'] = 'DejaVu Sans'
                plt.rcParams['font.sans-serif'] = ['DejaVu Sans', 'Arial', 'Liberation Sans']
                plt.rcParams['axes.unicode_minus'] = False
                plt.rcParams['font.size'] = 12
                
                self.logger.warning("‚ö†Ô∏è ÌïúÍ∏Ä Ìè∞Ìä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏñ¥ Í∏∞Î≥∏ Ìè∞Ìä∏ ÏÇ¨Ïö©: DejaVu Sans")
                
        except Exception as e:
            self.logger.error(f"Ìè∞Ìä∏ ÏÑ§Ï†ï Ï§ë Ïò§Î•ò Î∞úÏÉù: {e}")
            self.korean_font_name = "DejaVu Sans"
            self.korean_font_path = None
            rcParams['font.family'] = 'DejaVu Sans'
            rcParams['axes.unicode_minus'] = False
    
    def _apply_font_settings(self):
        """Í∞Å ÌîåÎ°Ø ÏÉùÏÑ± Ï†ÑÏóê Ìè∞Ìä∏ ÏÑ§Ï†ï Ïû¨Ï†ÅÏö©"""
        try:
            plt.rcParams['font.family'] = self.korean_font_name
            plt.rcParams['font.sans-serif'] = [self.korean_font_name] + ['DejaVu Sans', 'Arial']
            plt.rcParams['axes.unicode_minus'] = False
            plt.rcParams['font.size'] = 12
        except:
            plt.rcParams['font.family'] = 'DejaVu Sans'
            plt.rcParams['axes.unicode_minus'] = False
    
    def _setup_style(self):
        """ÏãúÍ∞ÅÌôî Ïä§ÌÉÄÏùº ÏÑ§Ï†ï"""
        plt.style.use('default')
        sns.set_palette(self.config.VISUALIZATION['color_palette'])
        
        # Í∏∞Î≥∏ ÏÑ§Ï†ï
        rcParams['figure.figsize'] = self.config.VISUALIZATION['figsize']
        rcParams['figure.dpi'] = self.config.VISUALIZATION['dpi']
        rcParams['font.size'] = self.config.VISUALIZATION['font_size']
        rcParams['axes.grid'] = True
        rcParams['grid.alpha'] = 0.3
    
    def plot_sentiment_trends(self, sentiment_trends: Dict, target_name: str) -> str:
        """
        Í∞êÏÑ± Ìä∏Î†åÎìú ÏãúÍ∞ÅÌôî (6Í∞ú Í∞êÏ†ï + Î≥ÄÌôî ÏÜçÎèÑ Ï§ëÏã¨ÏúºÎ°ú Í∞úÏÑ†)
        Args:
            sentiment_trends: Í∞êÏÑ± Ìä∏Î†åÎìú Îç∞Ïù¥ÌÑ∞
            target_name: Î∂ÑÏÑù ÎåÄÏÉÅ Ïù¥Î¶Ñ
        Returns:
            Ï†ÄÏû•Îêú ÌååÏùº Í≤ΩÎ°ú
        """
        try:
            self.logger.info(f"üìä {target_name} Í∞êÏÑ± Ìä∏Î†åÎìú ÏãúÍ∞ÅÌôî ÏãúÏûë")
            
            # Ìè∞Ìä∏ ÏÑ§Ï†ï Ïû¨Ï†ÅÏö©
            self._apply_font_settings()
            
            fig, axes = plt.subplots(2, 2, figsize=(20, 15))
            fig.suptitle(f'{target_name} Í∞êÏÑ± Î∂ÑÏÑù: ÏãúÍ∞ÑÏ†Å Î≥ÄÌôî Ìå®ÌÑ¥', fontsize=20, fontweight='bold')
            
            months = sentiment_trends['months']
            positive_ratios = sentiment_trends['positive_ratios']
            negative_ratios = sentiment_trends['negative_ratios']
            emotion_trends = sentiment_trends['emotion_trends']
            
            # 1. Í∏çÏ†ï/Î∂ÄÏ†ï ÎπÑÏú® Ìä∏Î†åÎìú + Î≥ÄÌôîÏú®
            axes[0, 0].plot(months, positive_ratios, marker='o', linewidth=3, 
                           label='Í∏çÏ†ï', color='#2E8B57', markersize=8)
            axes[0, 0].plot(months, negative_ratios, marker='s', linewidth=3, 
                           label='Î∂ÄÏ†ï', color='#DC143C', markersize=8)
            
            # Î≥ÄÌôîÏú® Í≥ÑÏÇ∞ Î∞è ÌëúÏãú
            if len(positive_ratios) > 1:
                pos_changes = np.diff(positive_ratios)
                neg_changes = np.diff(negative_ratios)
                
                # Í∏âÍ≤©Ìïú Î≥ÄÌôî Íµ¨Í∞Ñ ÌïòÏù¥ÎùºÏù¥Ìä∏
                for i, (pos_change, neg_change) in enumerate(zip(pos_changes, neg_changes)):
                    if abs(pos_change) > 0.1 or abs(neg_change) > 0.1:  # 10% Ïù¥ÏÉÅ Î≥ÄÌôî
                        axes[0, 0].axvspan(i, i+1, alpha=0.2, color='yellow', 
                                          label='Í∏âÎ≥ÄÍµ¨Í∞Ñ' if i == 0 else "")
            
            axes[0, 0].set_title('Í∏çÏ†ï/Î∂ÄÏ†ï Í∞êÏÑ± Î≥ÄÌôî + Í∏âÎ≥ÄÍµ¨Í∞Ñ', fontsize=16, fontweight='bold')
            axes[0, 0].set_ylabel('ÎπÑÏú®', fontsize=14)
            axes[0, 0].legend(fontsize=12)
            axes[0, 0].tick_params(axis='x', rotation=45)
            axes[0, 0].grid(True, alpha=0.3)
            
            # 2. 6Í∞ú Í∞êÏ†ï ÏÉÅÏÑ∏ Î∂ÑÏÑù
            emotion_colors = {
                'Î∂ÑÎÖ∏': '#FF4444', 'Ïä¨Ìîî': '#4444FF', 'Î∂àÏïà': '#FF8800',
                'ÏÉÅÏ≤ò': '#8800FF', 'ÎãπÌô©': '#00FF88', 'Í∏∞ÏÅ®': '#FFDD00'
            }
            
            # 6Í∞ú Í∞êÏ†ï Ìä∏Î†åÎìú ÌëúÏãú
            for emotion, values in emotion_trends.items():
                if emotion in emotion_colors:
                    axes[0, 1].plot(months, values, marker='o', linewidth=2.5, 
                                   label=emotion, color=emotion_colors[emotion], 
                                   markersize=6, alpha=0.8)
            
            axes[0, 1].set_title('6Í∞ú Í∞êÏ†ï ÏÉÅÏÑ∏ Î≥ÄÌôî Ï∂îÏù¥', fontsize=16, fontweight='bold')
            axes[0, 1].set_ylabel('Í∞êÏ†ï ÎπÑÏú®', fontsize=14)
            axes[0, 1].legend(fontsize=11, loc='upper right')
            axes[0, 1].tick_params(axis='x', rotation=45)
            axes[0, 1].grid(True, alpha=0.3)
            
            # ÏµúÍ≥†Ï†ê ÌëúÏãú
            for emotion, values in emotion_trends.items():
                if emotion in emotion_colors and max(values) > 0.05:  # 5% Ïù¥ÏÉÅÏù∏ Í∞êÏ†ïÎßå
                    max_idx = np.argmax(values)
                    max_value = values[max_idx]
                    axes[0, 1].annotate(f'{max_value:.1%}', 
                                       xy=(months[max_idx], max_value),
                                       xytext=(5, 5), textcoords='offset points',
                                       fontsize=9, alpha=0.8,
                                       bbox=dict(boxstyle='round,pad=0.3', 
                                               facecolor=emotion_colors[emotion], 
                                               alpha=0.3))
            
            # 3. Í∞êÏ†ï Î≥ÄÌôî ÏÜçÎèÑ (1Ï∞® ÎØ∏Î∂Ñ) - Ï£ºÏöî Í∞êÏ†ïÎßå
            emotion_velocities = {}
            significant_emotions = []
            
            # Ïú†ÏùòÎØ∏Ìïú Í∞êÏ†ï ÏÑ†Î≥Ñ (ÏµúÎåÄÍ∞íÏù¥ 3% Ïù¥ÏÉÅ)
            for emotion, values in emotion_trends.items():
                if emotion in emotion_colors and max(values) > 0.03:
                    significant_emotions.append((emotion, max(values)))
                    if len(values) > 1:
                        velocity = np.diff(values)
                        emotion_velocities[emotion] = velocity
            
            # ÏµúÎåÄÍ∞í Í∏∞Ï§ÄÏúºÎ°ú Ï†ïÎ†¨ÌïòÏó¨ ÏÉÅÏúÑ 4Í∞úÎßå ÌëúÏãú
            significant_emotions.sort(key=lambda x: x[1], reverse=True)
            top_emotions = [emotion for emotion, _ in significant_emotions[:4]]
            
            for emotion in top_emotions:
                if emotion in emotion_velocities:
                    velocity_months = months[1:]  # ÎØ∏Î∂ÑÏù¥ÎØÄÎ°ú Í∏∏Ïù¥Í∞Ä 1 Ï§ÑÏñ¥Îì¶
                    axes[1, 0].plot(velocity_months, emotion_velocities[emotion], 
                                   marker='o', linewidth=2.5, label=f'{emotion} Î≥ÄÌôîÏú®',
                                   color=emotion_colors[emotion], alpha=0.8, markersize=6)
            
            axes[1, 0].axhline(y=0, color='black', linestyle='--', alpha=0.5)
            axes[1, 0].set_title('Ï£ºÏöî Í∞êÏ†ï Î≥ÄÌôî ÏÜçÎèÑ (Ï¶ùÍ∞Ä/Í∞êÏÜå Ï∂îÏÑ∏)', fontsize=16, fontweight='bold')
            axes[1, 0].set_ylabel('Î≥ÄÌôîÏú® (ÏõîÍ∞Ñ)', fontsize=14)
            axes[1, 0].legend(fontsize=11, loc='upper right')
            axes[1, 0].tick_params(axis='x', rotation=45)
            axes[1, 0].grid(True, alpha=0.3)
            
            # Í∏âÍ≤©Ìïú Î≥ÄÌôî Íµ¨Í∞Ñ ÌëúÏãú
            for emotion in top_emotions:
                if emotion in emotion_velocities:
                    velocity = emotion_velocities[emotion]
                    threshold = np.std(velocity) * 1.5  # 1.5 ÌëúÏ§ÄÌé∏Ï∞® Ïù¥ÏÉÅ
                    for i, vel in enumerate(velocity):
                        if abs(vel) > threshold:
                            axes[1, 0].scatter(velocity_months[i], vel, 
                                             color=emotion_colors[emotion], 
                                             s=100, alpha=0.7, marker='*')
            
            # 4. Í∞êÏ†ï Îã§ÏñëÏÑ± Î∞è ÏßÄÎ∞∞Ï†Å Í∞êÏ†ï Î∂ÑÏÑù
            emotion_diversity = []
            dominant_emotions = []
            dominant_emotion_values = []
            
            for i in range(len(months)):
                month_emotions = [emotion_trends[emotion][i] for emotion in emotion_trends.keys()]
                # ÏóîÌä∏Î°úÌîº Í≥ÑÏÇ∞ (Í∞êÏ†ï Îã§ÏñëÏÑ±)
                month_emotions = np.array(month_emotions)
                month_emotions = month_emotions[month_emotions > 0]  # 0 Ï†úÍ±∞
                if len(month_emotions) > 0:
                    # Ï†ïÍ∑úÌôî
                    month_emotions = month_emotions / np.sum(month_emotions)
                    entropy = -np.sum(month_emotions * np.log(month_emotions + 1e-10))
                    emotion_diversity.append(entropy)
                    
                    # ÏßÄÎ∞∞Ï†Å Í∞êÏ†ï
                    emotion_values = [emotion_trends[emotion][i] for emotion in emotion_trends.keys()]
                    max_emotion_idx = np.argmax(emotion_values)
                    emotion_names = list(emotion_trends.keys())
                    dominant_emotion = emotion_names[max_emotion_idx]
                    dominant_emotions.append(dominant_emotion)
                    dominant_emotion_values.append(emotion_values[max_emotion_idx])
                else:
                    emotion_diversity.append(0)
                    dominant_emotions.append('Ï§ëÎ¶Ω')
                    dominant_emotion_values.append(0)
            
            # Îã§ÏñëÏÑ± ÏßÄÏàò ÎùºÏù∏ ÌîåÎ°Ø
            line = axes[1, 1].plot(months, emotion_diversity, marker='o', linewidth=3, 
                                  color='#4169E1', markersize=8, label='Í∞êÏ†ï Îã§ÏñëÏÑ±')
            axes[1, 1].set_ylabel('Îã§ÏñëÏÑ± ÏßÄÏàò', fontsize=14, color='#4169E1')
            axes[1, 1].tick_params(axis='y', labelcolor='#4169E1')
            
            # ÏßÄÎ∞∞Ï†Å Í∞êÏ†ïÏùÑ ÏÉâÏÉÅÏúºÎ°ú ÌëúÏãú (Ïö∞Ï∏° yÏ∂ï)
            ax2 = axes[1, 1].twinx()
            for i, (month, emotion, value) in enumerate(zip(months, dominant_emotions, dominant_emotion_values)):
                if emotion in emotion_colors:
                    ax2.bar(month, value, color=emotion_colors[emotion], alpha=0.6, width=0.8)
            
            ax2.set_ylabel('ÏßÄÎ∞∞Ï†Å Í∞êÏ†ï Í∞ïÎèÑ', fontsize=14, color='#DC143C')
            ax2.tick_params(axis='y', labelcolor='#DC143C')
            
            axes[1, 1].set_title('Í∞êÏ†ï Îã§ÏñëÏÑ± vs ÏßÄÎ∞∞Ï†Å Í∞êÏ†ï', fontsize=16, fontweight='bold')
            axes[1, 1].tick_params(axis='x', rotation=45)
            axes[1, 1].grid(True, alpha=0.3)
            
            # Î≤îÎ°Ä Ï∂îÍ∞Ä
            emotion_legend = [plt.Rectangle((0,0),1,1, color=color, alpha=0.6) 
                             for emotion, color in emotion_colors.items()]
            emotion_labels = list(emotion_colors.keys())
            axes[1, 1].legend(emotion_legend, emotion_labels, 
                             loc='upper left', fontsize=10, title='ÏßÄÎ∞∞Ï†Å Í∞êÏ†ï')
            
            plt.tight_layout()
            
            # ÌååÏùº Ï†ÄÏû•
            filename = f"{target_name}_sentiment_trends.png"
            filepath = os.path.join(self.output_dir, filename)
            
            # ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
            os.makedirs(os.path.dirname(filepath), exist_ok=True)
            
            plt.savefig(filepath, dpi=self.config.VISUALIZATION['dpi'], 
                       bbox_inches='tight', facecolor='white')
            plt.close()
            
            self.logger.info(f"‚úÖ Í∞êÏÑ± Ìä∏Î†åÎìú ÏãúÍ∞ÅÌôî ÏôÑÎ£å: {filepath}")
            return filepath
            
        except Exception as e:
            self.logger.error(f"‚ùå Í∞êÏÑ± Ìä∏Î†åÎìú ÏãúÍ∞ÅÌôî Ïã§Ìå®: {str(e)}")
            raise
    
    def _save_period_topic_changes_to_file(self, comprehensive_results: Dict, target_name: str, time_unit: str):
        """
        Í∏∞Í∞ÑÎ≥Ñ ÌÜ†ÌîΩ Î≥ÄÌôîÎ•º ÌÖçÏä§Ìä∏ ÌååÏùºÎ°ú Ï†ÄÏû•
        Args:
            comprehensive_results: Ï¢ÖÌï© Î∂ÑÏÑù Í≤∞Í≥º
            target_name: Î∂ÑÏÑù ÎåÄÏÉÅ Ïù¥Î¶Ñ  
            time_unit: ÏãúÍ∞Ñ Îã®ÏúÑ
        """
        try:
            # BERTopic Í∏∞Í∞ÑÎ≥Ñ Î≥ÄÌôî Î∂ÑÏÑù
            bertopic_changes = []
            lda_changes = []
            
            sorted_periods = sorted(comprehensive_results.keys())
            
            for period in sorted_periods:
                result = comprehensive_results[period]
                
                # BERTopic Î∂ÑÏÑù
                if 'bertopic' in result and result['bertopic'].get('topic_labels'):
                    bertopic_labels = result['bertopic']['topic_labels']
                    bertopic_changes.append(f"=== {period} ===")
                    bertopic_changes.append(f"Ï¥ù ÎåìÍ∏Ä Ïàò: {result['total_comments']:,}Í∞ú")
                    bertopic_changes.append(f"Î∞úÍ≤¨Îêú ÌÜ†ÌîΩ Ïàò: {len(bertopic_labels)}Í∞ú")
                    bertopic_changes.append("Ï£ºÏöî ÌÜ†ÌîΩ:")
                    for i, label in enumerate(bertopic_labels[:5], 1):
                        bertopic_changes.append(f"  {i}. {label}")
                    bertopic_changes.append("")
                
                # LDA Î∂ÑÏÑù
                if 'lda' in result and result['lda'].get('topic_labels'):
                    lda_labels = result['lda']['topic_labels']
                    lda_changes.append(f"=== {period} ===")
                    lda_changes.append(f"Ï¥ù ÎåìÍ∏Ä Ïàò: {result['total_comments']:,}Í∞ú")
                    lda_changes.append(f"Î∞úÍ≤¨Îêú ÌÜ†ÌîΩ Ïàò: {len(lda_labels)}Í∞ú")
                    lda_changes.append(f"ÏùºÍ¥ÄÏÑ± Ï†êÏàò: {result['lda'].get('coherence_score', 0):.3f}")
                    lda_changes.append("Ï£ºÏöî ÌÜ†ÌîΩ:")
                    for i, label in enumerate(lda_labels[:5], 1):
                        lda_changes.append(f"  {i}. {label}")
                    lda_changes.append("")
            
            # BERTopic Î≥ÄÌôî ÌååÏùº Ï†ÄÏû•
            if bertopic_changes:
                bertopic_file = os.path.join(
                    self.config.OUTPUT_STRUCTURE['data_processed'],
                    f'{target_name}_BERTopic_{time_unit}_Î≥ÄÌôî.txt'
                )
                with open(bertopic_file, 'w', encoding='utf-8') as f:
                    f.write(f"{target_name} BERTopic Í∏∞Í∞ÑÎ≥Ñ Î≥ÄÌôî Î∂ÑÏÑù\n")
                    f.write(f"ÏãúÍ∞Ñ Îã®ÏúÑ: {time_unit}\n")
                    f.write(f"Î∂ÑÏÑù ÏùºÏãú: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                    f.write("=" * 60 + "\n\n")
                    f.write("\n".join(bertopic_changes))
                
                self.logger.info(f"üìÑ BERTopic Í∏∞Í∞ÑÎ≥Ñ Î≥ÄÌôî Ï†ÄÏû•: {bertopic_file}")
            
            # LDA Î≥ÄÌôî ÌååÏùº Ï†ÄÏû•
            if lda_changes:
                lda_file = os.path.join(
                    self.config.OUTPUT_STRUCTURE['data_processed'],
                    f'{target_name}_LDA_{time_unit}_Î≥ÄÌôî.txt'
                )
                with open(lda_file, 'w', encoding='utf-8') as f:
                    f.write(f"{target_name} LDA Í∏∞Í∞ÑÎ≥Ñ Î≥ÄÌôî Î∂ÑÏÑù\n")
                    f.write(f"ÏãúÍ∞Ñ Îã®ÏúÑ: {time_unit}\n")
                    f.write(f"Î∂ÑÏÑù ÏùºÏãú: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                    f.write("=" * 60 + "\n\n")
                    f.write("\n".join(lda_changes))
                
                self.logger.info(f"üìÑ LDA Í∏∞Í∞ÑÎ≥Ñ Î≥ÄÌôî Ï†ÄÏû•: {lda_file}")
                
        except Exception as e:
            self.logger.error(f"‚ùå Í∏∞Í∞ÑÎ≥Ñ ÌÜ†ÌîΩ Î≥ÄÌôî ÌååÏùº Ï†ÄÏû• Ïã§Ìå®: {str(e)}")
    
    def _plot_topic_count_trends(self, filtered_results: Dict, ax, model_name: str):
        """
        ÌÜ†ÌîΩ Ïàò Î≥ÄÌôî Ìä∏Î†åÎìú ÌîåÎ°Ø
        Args:
            filtered_results: ÌïÑÌÑ∞ÎßÅÎêú Í≤∞Í≥º
            ax: matplotlib axes
            model_name: Î™®Îç∏ Ïù¥Î¶Ñ ('BERTopic' ÎòêÎäî 'LDA')
        """
        try:
            periods = sorted(filtered_results.keys())
            topic_counts = []
            
            model_key = 'bertopic' if model_name == 'BERTopic' else 'lda'
            
            for period in periods:
                result = filtered_results[period]
                if model_key in result and result[model_key].get('topic_labels'):
                    topic_counts.append(len(result[model_key]['topic_labels']))
                else:
                    topic_counts.append(0)
            
            # ÌîåÎ°Ø ÏÉùÏÑ±
            ax.plot(range(len(periods)), topic_counts, marker='o', linewidth=2, markersize=8,
                   color='#4CAF50' if model_name == 'BERTopic' else '#FF9800')
            ax.set_title(f'{model_name} ÌÜ†ÌîΩ Ïàò Î≥ÄÌôî', fontsize=14, fontweight='bold')
            ax.set_ylabel('ÌÜ†ÌîΩ Ïàò', fontsize=12)
            ax.set_xticks(range(len(periods)))
            ax.set_xticklabels([p[:10] + '...' if len(p) > 10 else p for p in periods], 
                                      rotation=45, ha='right')
            ax.grid(True, alpha=0.3)
            
            # Í∞í ÌëúÏãú
            for i, count in enumerate(topic_counts):
                if count > 0:
                    ax.text(i, count + 0.1, str(count), ha='center', va='bottom', fontsize=10)
                    
        except Exception as e:
            self.logger.error(f"‚ùå {model_name} ÌÜ†ÌîΩ Ïàò Ìä∏Î†åÎìú ÌîåÎ°Ø Ïã§Ìå®: {str(e)}")
            ax.text(0.5, 0.5, f'{model_name} Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå', ha='center', va='center', 
                   transform=ax.transAxes, fontsize=12)

    def _plot_lda_analysis(self, filtered_results: Dict, ax):
        """
        LDA Î∂ÑÏÑù Í≤∞Í≥º ÌîåÎ°Ø (ÌÜ†ÌîΩ Ïàò + ÏùºÍ¥ÄÏÑ±)
        Args:
            filtered_results: ÌïÑÌÑ∞ÎßÅÎêú Í≤∞Í≥º
            ax: matplotlib axes
        """
        try:
            periods = sorted(filtered_results.keys())
            topic_counts = []
            coherence_scores = []
            
            for period in periods:
                result = filtered_results[period]
                if 'lda' in result and result['lda'].get('topic_labels'):
                    topic_counts.append(len(result['lda']['topic_labels']))
                    coherence_scores.append(result['lda'].get('coherence_score', 0))
                else:
                    topic_counts.append(0)
                    coherence_scores.append(0)
            
            # Ïù¥Ï§ë yÏ∂ï ÏÑ§Ï†ï
            ax2 = ax.twinx()
                
            # ÌÜ†ÌîΩ Ïàò (ÎßâÎåÄ Í∑∏ÎûòÌîÑ)
            bars = ax.bar(range(len(periods)), topic_counts, alpha=0.7, color='#FF9800', 
                         label='ÌÜ†ÌîΩ Ïàò')
            
            # ÏùºÍ¥ÄÏÑ± Ï†êÏàò (ÏÑ† Í∑∏ÎûòÌîÑ)
            line = ax2.plot(range(len(periods)), coherence_scores, 'r-o', linewidth=2, 
                           markersize=6, label='ÏùºÍ¥ÄÏÑ± Ï†êÏàò')
            
            ax.set_title('LDA ÌÜ†ÌîΩ Ïàò Î∞è ÏùºÍ¥ÄÏÑ± Î≥ÄÌôî', fontsize=14, fontweight='bold')
            ax.set_ylabel('ÌÜ†ÌîΩ Ïàò', fontsize=12, color='#FF9800')
            ax2.set_ylabel('ÏùºÍ¥ÄÏÑ± Ï†êÏàò', fontsize=12, color='red')
            
            ax.set_xticks(range(len(periods)))
            ax.set_xticklabels([p[:10] + '...' if len(p) > 10 else p for p in periods], 
                              rotation=45, ha='right')
            
            ax.grid(True, alpha=0.3)
            
            # Î≤îÎ°Ä
            lines1, labels1 = ax.get_legend_handles_labels()
            lines2, labels2 = ax2.get_legend_handles_labels()
            ax.legend(lines1 + lines2, labels1 + labels2, loc='upper left')
                
            # Í∞í ÌëúÏãú
            for i, (count, score) in enumerate(zip(topic_counts, coherence_scores)):
                if count > 0:
                    ax.text(i, count + 0.1, str(count), ha='center', va='bottom', fontsize=9)
                if score > 0:
                    ax2.text(i, score + 0.01, f'{score:.2f}', ha='center', va='bottom', 
                            fontsize=9, color='red')
                    
        except Exception as e:
            self.logger.error(f"‚ùå LDA Î∂ÑÏÑù ÌîåÎ°Ø Ïã§Ìå®: {str(e)}")
            ax.text(0.5, 0.5, 'LDA Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå', ha='center', va='center', 
                   transform=ax.transAxes, fontsize=12)

    def create_topic_analysis_dashboard(self, comprehensive_results: Dict, target_name: str, 
                                      time_unit: str, min_comments_threshold: int = 50) -> str:
        """
        ÌÜ†ÌîΩ Î∂ÑÏÑù ÎåÄÏãúÎ≥¥Îìú ÏÉùÏÑ± (1x2 Î†àÏù¥ÏïÑÏõÉ)
        Args:
            comprehensive_results: Ï¢ÖÌï© Î∂ÑÏÑù Í≤∞Í≥º
            target_name: Î∂ÑÏÑù ÎåÄÏÉÅ Ïù¥Î¶Ñ
            time_unit: ÏãúÍ∞Ñ Îã®ÏúÑ
            min_comments_threshold: ÏµúÏÜå ÎåìÍ∏Ä Ïàò ÏûÑÍ≥ÑÍ∞í
        Returns:
            Ï†ÄÏû•Îêú ÌååÏùº Í≤ΩÎ°ú
        """
        try:
            self.logger.info(f"üîç {target_name} ÌÜ†ÌîΩ Î∂ÑÏÑù ÎåÄÏãúÎ≥¥Îìú ÏÉùÏÑ± ÏãúÏûë")
            
            # Í∏∞Í∞ÑÎ≥Ñ ÌÜ†ÌîΩ Î≥ÄÌôîÎ•º ÌÖçÏä§Ìä∏ ÌååÏùºÎ°ú Ï†ÄÏû•
            self._save_period_topic_changes_to_file(comprehensive_results, target_name, time_unit)
            
            # Ï∂©Î∂ÑÌïú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÎäî Í∏∞Í∞ÑÎßå ÌïÑÌÑ∞ÎßÅ
            filtered_results = {
                period: result for period, result in comprehensive_results.items()
                if result['total_comments'] >= min_comments_threshold
            }
            
            if not filtered_results:
                self.logger.warning(f"‚ö†Ô∏è ÏµúÏÜå ÎåìÍ∏Ä Ïàò({min_comments_threshold})Î•º ÎßåÏ°±ÌïòÎäî Í∏∞Í∞ÑÏù¥ ÏóÜÏäµÎãàÎã§.")
                return None
            
            # 1x2 Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï
            fig, axes = plt.subplots(1, 2, figsize=(20, 8))
            fig.suptitle(f'{target_name} ÌÜ†ÌîΩ Î∂ÑÏÑù ÎåÄÏãúÎ≥¥Îìú ({time_unit})', fontsize=16, fontweight='bold')
            
            # 1. BERTopic ÌÜ†ÌîΩ Ïàò Î≥ÄÌôî
            self._plot_topic_count_trends(filtered_results, axes[0], 'BERTopic')
            
            # 2. LDA ÌÜ†ÌîΩ Ïàò Î≥ÄÌôî Î∞è ÏùºÍ¥ÄÏÑ±
            self._plot_lda_analysis(filtered_results, axes[1])
            
            plt.tight_layout()
            
            # ÌååÏùº Ï†ÄÏû•
            filename = f'{target_name}_topic_dashboard_{time_unit}.png'
            filepath = os.path.join(self.config.OUTPUT_STRUCTURE['visualizations'], filename)
            plt.savefig(filepath, dpi=self.config.VISUALIZATION['dpi'], bbox_inches='tight')
            plt.close()
            
            self.logger.info(f"‚úÖ ÌÜ†ÌîΩ Î∂ÑÏÑù ÎåÄÏãúÎ≥¥Îìú Ï†ÄÏû•: {filepath}")
            return filepath
            
        except Exception as e:
            self.logger.error(f"‚ùå ÌÜ†ÌîΩ Î∂ÑÏÑù ÎåÄÏãúÎ≥¥Îìú ÏÉùÏÑ± Ïã§Ìå®: {str(e)}")
            return None
    
    def plot_topic_evolution(self, topic_evolution: Dict, target_name: str) -> str:
        """
        ÌÜ†ÌîΩ ÏßÑÌôî ÏãúÍ∞ÅÌôî (ÌîÑÎ†àÏûÑ Î≥ÄÌôî Ï§ëÏã¨ÏúºÎ°ú Í∞úÏÑ†)
        Args:
            topic_evolution: ÌÜ†ÌîΩ ÏßÑÌôî Îç∞Ïù¥ÌÑ∞
            target_name: Î∂ÑÏÑù ÎåÄÏÉÅ Ïù¥Î¶Ñ
        Returns:
            Ï†ÄÏû•Îêú ÌååÏùº Í≤ΩÎ°ú
        """
        try:
            self.logger.info(f"üîç {target_name} ÌÜ†ÌîΩ ÏßÑÌôî ÏãúÍ∞ÅÌôî ÏãúÏûë")
            
            # Ìè∞Ìä∏ ÏÑ§Ï†ï Ïû¨Ï†ÅÏö©
            self._apply_font_settings()
            plt.rcParams['axes.unicode_minus'] = False
            
            fig, axes = plt.subplots(2, 2, figsize=(20, 15))
            fig.suptitle(f'{target_name} ÌÜ†ÌîΩ ÌîÑÎ†àÏûÑ Î≥ÄÌôî Î∂ÑÏÑù', fontsize=20, fontweight='bold')
            
            bertopic_data = topic_evolution['bertopic_evolution']
            lda_data = topic_evolution['lda_evolution']
            
            months = bertopic_data['months']
            
            # 1. ÌÜ†ÌîΩ Î≥µÏû°ÎèÑ Î≥ÄÌôî (ÌÜ†ÌîΩ Ïàò + ÏùºÍ¥ÄÏÑ±)
            axes[0, 0].plot(months, bertopic_data['topic_counts'], marker='o', 
                           linewidth=3, label='BERTopic ÌÜ†ÌîΩ Ïàò', color='#4CAF50', markersize=8)
            
            # Ïù¥Ï∞® yÏ∂ïÏúºÎ°ú ÏùºÍ¥ÄÏÑ± Ï†êÏàò Ï∂îÍ∞Ä
            ax2 = axes[0, 0].twinx()
            if lda_data['coherence_scores']:
                ax2.plot(months, lda_data['coherence_scores'], marker='D', 
                        linewidth=3, color='#9C27B0', markersize=8, label='LDA ÏùºÍ¥ÄÏÑ±')
                ax2.set_ylabel('ÏùºÍ¥ÄÏÑ± Ï†êÏàò', fontsize=14, color='#9C27B0')
                ax2.tick_params(axis='y', labelcolor='#9C27B0')
            
            axes[0, 0].set_title('ÌÜ†ÌîΩ Î≥µÏû°ÎèÑ vs ÏùºÍ¥ÄÏÑ± Î≥ÄÌôî', fontsize=16, fontweight='bold')
            axes[0, 0].set_ylabel('ÌÜ†ÌîΩ Ïàò', fontsize=14, color='#4CAF50')
            axes[0, 0].tick_params(axis='y', labelcolor='#4CAF50')
            axes[0, 0].tick_params(axis='x', rotation=45)
            axes[0, 0].grid(True, alpha=0.3)
            
            # Î≤îÎ°Ä ÌÜµÌï©
            lines1, labels1 = axes[0, 0].get_legend_handles_labels()
            if lda_data['coherence_scores']:
                lines2, labels2 = ax2.get_legend_handles_labels()
                axes[0, 0].legend(lines1 + lines2, labels1 + labels2, loc='upper left')
            else:
                axes[0, 0].legend()
            
            # 2. ÌÜ†ÌîΩ Ï†ÑÌôò Ìå®ÌÑ¥ (Ï£ºÏöî ÌÜ†ÌîΩÏùò Îì±Ïû•/ÏÜåÎ©∏)
            # Í∞Å Í∏∞Í∞ÑÎ≥Ñ Ï£ºÏöî ÌÜ†ÌîΩ Î≥ÄÌôîÎ•º Ï∂îÏ†Å
            topic_transitions = []
            prev_topics = set()
            
            for i, month in enumerate(months):
                current_topics = set()
                if i < len(bertopic_data['main_topics']):
                    current_topic = bertopic_data['main_topics'][i]
                    if current_topic:
                        current_topics.add(current_topic)
                
                # ÏÉàÎ°ú Îì±Ïû•Ìïú ÌÜ†ÌîΩ
                new_topics = current_topics - prev_topics
                # ÏÇ¨ÎùºÏßÑ ÌÜ†ÌîΩ
                disappeared_topics = prev_topics - current_topics
                
                transition_score = len(new_topics) + len(disappeared_topics)
                topic_transitions.append(transition_score)
                prev_topics = current_topics
            
            bars = axes[0, 1].bar(months, topic_transitions, color='#FF6B6B', alpha=0.7)
            axes[0, 1].set_title('ÌÜ†ÌîΩ Ï†ÑÌôò Í∞ïÎèÑ (ÌîÑÎ†àÏûÑ Î≥ÄÌôî)', fontsize=16, fontweight='bold')
            axes[0, 1].set_ylabel('Ï†ÑÌôò Ï†êÏàò', fontsize=14)
            axes[0, 1].tick_params(axis='x', rotation=45)
            axes[0, 1].grid(True, alpha=0.3)
            
            # ÎÜíÏùÄ Ï†ÑÌôò Íµ¨Í∞Ñ ÌïòÏù¥ÎùºÏù¥Ìä∏
            max_transition = max(topic_transitions) if topic_transitions else 0
            for i, (bar, score) in enumerate(zip(bars, topic_transitions)):
                if score > max_transition * 0.7:  # ÏÉÅÏúÑ 30% Ï†ÑÌôò Íµ¨Í∞Ñ
                    bar.set_color('#FF4444')
                    axes[0, 1].text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.1,
                                   'Í∏âÎ≥Ä', ha='center', va='bottom', fontsize=10, fontweight='bold')
            
            # 3. ÌÜ†ÌîΩ ÏßÄÏÜçÏÑ± Î∂ÑÏÑù (Ïó∞ÏÜçÏÑ± vs Îã®Î∞úÏÑ±)
            topic_persistence = {}
            for i, topic in enumerate(bertopic_data['main_topics']):
                if topic:
                    if topic not in topic_persistence:
                        topic_persistence[topic] = []
                    topic_persistence[topic].append(i)
            
            # ÏßÄÏÜçÏÑ± Ï†êÏàò Í≥ÑÏÇ∞ (Ïó∞ÏÜçÎêú Í∏∞Í∞ÑÏùò Í∏∏Ïù¥)
            persistence_scores = []
            for month_idx in range(len(months)):
                current_topic = bertopic_data['main_topics'][month_idx] if month_idx < len(bertopic_data['main_topics']) else None
                if current_topic and current_topic in topic_persistence:
                    appearances = topic_persistence[current_topic]
                    # ÌòÑÏû¨ ÏãúÏ†ê Í∏∞Ï§Ä Ïó∞ÏÜçÏÑ± Í≥ÑÏÇ∞
                    consecutive_count = 1
                    for j in range(month_idx - 1, -1, -1):
                        if j in appearances:
                            consecutive_count += 1
                        else:
                            break
                    persistence_scores.append(consecutive_count)
                else:
                    persistence_scores.append(0)
            
            axes[1, 0].plot(months, persistence_scores, marker='o', linewidth=3, 
                           color='#4ECDC4', markersize=8)
            axes[1, 0].set_title('ÌÜ†ÌîΩ ÏßÄÏÜçÏÑ± (Ïó∞ÏÜç Ï∂úÌòÑ Í∏∞Í∞Ñ)', fontsize=16, fontweight='bold')
            axes[1, 0].set_ylabel('Ïó∞ÏÜç Í∏∞Í∞Ñ', fontsize=14)
            axes[1, 0].tick_params(axis='x', rotation=45)
            axes[1, 0].grid(True, alpha=0.3)
            
            # ÏßÄÏÜçÏÑ± Íµ¨Í∞ÑÎ≥Ñ ÏÉâÏÉÅ Íµ¨Î∂Ñ
            for i, score in enumerate(persistence_scores):
                if score >= 3:  # 3Í∞úÏõî Ïù¥ÏÉÅ ÏßÄÏÜç
                    axes[1, 0].scatter(months[i], score, color='green', s=100, alpha=0.7, label='Ïû•Í∏∞ ÏßÄÏÜç' if i == 0 else "")
                elif score == 2:
                    axes[1, 0].scatter(months[i], score, color='orange', s=100, alpha=0.7, label='Ï§ëÍ∏∞ ÏßÄÏÜç' if i == 0 else "")
                elif score == 1:
                    axes[1, 0].scatter(months[i], score, color='red', s=100, alpha=0.7, label='Îã®Î∞úÏÑ±' if i == 0 else "")
            
            # 4. ÌÜ†ÌîΩ ÌÇ§ÏõåÎìú Î≥ÄÌôîÏú® (ÏùòÎØ∏Ï†Å Î≥ÄÌôî)
            # Í∞Å Í∏∞Í∞ÑÎ≥Ñ Ï£ºÏöî ÌÇ§ÏõåÎìúÏùò Î≥ÄÌôîÎ•º Ï∏°Ï†ï
            keyword_changes = []
            prev_keywords = set()
            
            for i, month in enumerate(months):
                current_keywords = set()
                
                # BERTopicÏóêÏÑú ÌòÑÏû¨ Í∏∞Í∞ÑÏùò Ï£ºÏöî ÌÇ§ÏõåÎìú Ï∂îÏ∂ú
                if 'topic_words' in bertopic_data and i < len(bertopic_data.get('topic_words', [])):
                    topic_words = bertopic_data['topic_words'][i] if isinstance(bertopic_data['topic_words'], list) else {}
                    if isinstance(topic_words, dict):
                        for words in topic_words.values():
                            if isinstance(words, list):
                                current_keywords.update(words[:5])  # ÏÉÅÏúÑ 5Í∞ú ÌÇ§ÏõåÎìú
                
                # ÌÇ§ÏõåÎìú Î≥ÄÌôîÏú® Í≥ÑÏÇ∞ (ÏûêÏπ¥Îìú Í±∞Î¶¨)
                if prev_keywords and current_keywords:
                    intersection = len(prev_keywords & current_keywords)
                    union = len(prev_keywords | current_keywords)
                    jaccard_similarity = intersection / union if union > 0 else 0
                    change_rate = 1 - jaccard_similarity
                else:
                    change_rate = 1.0 if current_keywords else 0.0
                
                keyword_changes.append(change_rate)
                prev_keywords = current_keywords
            
            axes[1, 1].plot(months, keyword_changes, marker='s', linewidth=3, 
                           color='#FF9500', markersize=8)
            axes[1, 1].set_title('ÌÜ†ÌîΩ ÏùòÎØ∏ Î≥ÄÌôîÏú® (ÌÇ§ÏõåÎìú Í∏∞Ï§Ä)', fontsize=16, fontweight='bold')
            axes[1, 1].set_ylabel('Î≥ÄÌôîÏú® (0=ÎèôÏùº, 1=ÏôÑÏ†ÑÎ≥ÄÌôî)', fontsize=14)
            axes[1, 1].set_ylim(0, 1.1)
            axes[1, 1].tick_params(axis='x', rotation=45)
            axes[1, 1].grid(True, alpha=0.3)
            
            # Í∏âÍ≤©Ìïú ÏùòÎØ∏ Î≥ÄÌôî Íµ¨Í∞Ñ ÌïòÏù¥ÎùºÏù¥Ìä∏
            for i, change in enumerate(keyword_changes):
                if change > 0.7:  # 70% Ïù¥ÏÉÅ Î≥ÄÌôî
                    axes[1, 1].scatter(months[i], change, color='red', s=150, alpha=0.8, marker='*')
                    axes[1, 1].text(months[i], change + 0.05, 'Í∏âÎ≥Ä', ha='center', va='bottom', 
                                   fontsize=10, fontweight='bold', color='red')
            
            plt.tight_layout()
            
            # ÌååÏùº Ï†ÄÏû•
            filename = f"{target_name}_topic_evolution.png"
            filepath = os.path.join(self.output_dir, filename)
            
            # ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
            os.makedirs(os.path.dirname(filepath), exist_ok=True)
            
            plt.savefig(filepath, dpi=self.config.VISUALIZATION['dpi'], 
                       bbox_inches='tight', facecolor='white')
            plt.close()
            
            self.logger.info(f"‚úÖ ÌÜ†ÌîΩ ÏßÑÌôî ÏãúÍ∞ÅÌôî ÏôÑÎ£å: {filepath}")
            return filepath
            
        except Exception as e:
            self.logger.error(f"‚ùå ÌÜ†ÌîΩ ÏßÑÌôî ÏãúÍ∞ÅÌôî Ïã§Ìå®: {str(e)}")
            raise
    
    def create_time_grouped_wordclouds(self, time_group_results: Dict, target_name: str, 
                                     min_comments_threshold: int = 50) -> List[str]:
        """
        ÏãúÍ∞Ñ Í∑∏Î£πÎ≥Ñ WordCloud ÏÉùÏÑ± (Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°± Íµ¨Í∞Ñ ÌïÑÌÑ∞ÎßÅ)
        Args:
            time_group_results: ÏãúÍ∞Ñ Í∑∏Î£πÎ≥Ñ Î∂ÑÏÑù Í≤∞Í≥º
            target_name: Î∂ÑÏÑù ÎåÄÏÉÅ Ïù¥Î¶Ñ
            min_comments_threshold: ÏµúÏÜå ÎåìÍ∏Ä Ïàò ÏûÑÍ≥ÑÍ∞í
        Returns:
            Ï†ÄÏû•Îêú ÌååÏùº Í≤ΩÎ°ú Î¶¨Ïä§Ìä∏
        """
        try:
            self.logger.info(f"‚òÅÔ∏è {target_name} ÏãúÍ∞Ñ Í∑∏Î£πÎ≥Ñ ÏõåÎìúÌÅ¥ÎùºÏö∞Îìú ÏÉùÏÑ± ÏãúÏûë")
            
            saved_files = []
            
            for period, result in time_group_results.items():
                comment_count = result.get('total_comments', 0)
                
                # Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°± Íµ¨Í∞Ñ ÌïÑÌÑ∞ÎßÅ
                if comment_count < min_comments_threshold:
                    self.logger.info(f"‚ö†Ô∏è {period}: ÎåìÍ∏Ä Ïàò Î∂ÄÏ°±({comment_count}Í∞ú), ÏõåÎìúÌÅ¥ÎùºÏö∞Îìú ÏÉùÎûµ")
                    continue
                
                # ÌÇ§ÏõåÎìú Ï∂îÏ∂ú (BERTopic ÎòêÎäî LDAÏóêÏÑú)
                keywords = []
                
                # BERTopic ÌÇ§ÏõåÎìú Ïö∞ÏÑ† ÏÇ¨Ïö©
                if 'bertopic' in result and result['bertopic']:
                    bertopic_result = result['bertopic']
                    topic_words = bertopic_result.get('topic_words', {})
                    
                    for topic_id, words in topic_words.items():
                        if isinstance(words, list) and len(words) > 0:
                            for word, score in words[:10]:  # Í∞Å ÌÜ†ÌîΩÏóêÏÑú ÏÉÅÏúÑ 10Í∞ú
                                keywords.append((word, int(score * 100)))  # Ï†êÏàòÎ•º Ï†ïÏàòÎ°ú Î≥ÄÌôò
                
                # BERTopicÏù¥ ÏóÜÏúºÎ©¥ LDA ÏÇ¨Ïö©
                elif 'lda' in result and result['lda']:
                    lda_result = result['lda']
                    topic_words = lda_result.get('topic_words', {})
                    
                    for topic_id, words in topic_words.items():
                        if isinstance(words, list) and len(words) > 0:
                            for word, score in words[:10]:  # Í∞Å ÌÜ†ÌîΩÏóêÏÑú ÏÉÅÏúÑ 10Í∞ú
                                keywords.append((word, int(score * 100)))  # Ï†êÏàòÎ•º Ï†ïÏàòÎ°ú Î≥ÄÌôò
                
                if not keywords:
                    self.logger.warning(f"‚ö†Ô∏è {period}: ÌÇ§ÏõåÎìúÍ∞Ä ÏóÜÏñ¥ ÏõåÎìúÌÅ¥ÎùºÏö∞Îìú ÏÉùÏÑ± Î∂àÍ∞Ä")
                    continue
                
                # Ï§ëÎ≥µ ÌÇ§ÏõåÎìú Ï†úÍ±∞ Î∞è ÎπàÎèÑ Ìï©ÏÇ∞
                keyword_dict = {}
                for word, freq in keywords:
                    if word in keyword_dict:
                        keyword_dict[word] += freq
                    else:
                        keyword_dict[word] = freq
                
                # ÏÉÅÏúÑ ÌÇ§ÏõåÎìúÎßå ÏÑ†ÌÉù
                top_keywords = sorted(keyword_dict.items(), key=lambda x: x[1], reverse=True)[:50]
                
                if len(top_keywords) < 5:
                    self.logger.warning(f"‚ö†Ô∏è {period}: Ïú†Ìö®Ìïú ÌÇ§ÏõåÎìúÍ∞Ä ÎÑàÎ¨¥ Ï†ÅÏùå({len(top_keywords)}Í∞ú)")
                    continue
                
                # ÏõåÎìúÌÅ¥ÎùºÏö∞Îìú ÏÉùÏÑ±
                filepath = self.create_wordcloud(top_keywords, target_name, period)
                if filepath:
                    saved_files.append(filepath)
                    self.logger.info(f"‚úÖ {period} ÏõåÎìúÌÅ¥ÎùºÏö∞Îìú ÏÉùÏÑ±: {comment_count}Í∞ú ÎåìÍ∏Ä")
            
            self.logger.info(f"‚úÖ ÏãúÍ∞Ñ Í∑∏Î£πÎ≥Ñ ÏõåÎìúÌÅ¥ÎùºÏö∞Îìú ÏÉùÏÑ± ÏôÑÎ£å: {len(saved_files)}Í∞ú")
            return saved_files
            
        except Exception as e:
            self.logger.error(f"‚ùå ÏãúÍ∞Ñ Í∑∏Î£πÎ≥Ñ ÏõåÎìúÌÅ¥ÎùºÏö∞Îìú ÏÉùÏÑ± Ïã§Ìå®: {str(e)}")
            return []
    
    def create_wordcloud(self, keywords: List[Tuple[str, int]], target_name: str, 
                        period: str = None) -> str:
        """
        ÏõåÎìúÌÅ¥ÎùºÏö∞Îìú ÏÉùÏÑ±
        Args:
            keywords: (ÌÇ§ÏõåÎìú, ÎπàÎèÑ) ÌäúÌîå Î¶¨Ïä§Ìä∏
            target_name: Î∂ÑÏÑù ÎåÄÏÉÅ Ïù¥Î¶Ñ
            month: Ïõî (ÏÑ†ÌÉùÏÇ¨Ìï≠)
        Returns:
            Ï†ÄÏû•Îêú ÌååÏùº Í≤ΩÎ°ú
        """
        try:
            period_str = f"_{period}" if period else ""
            self.logger.info(f"‚òÅÔ∏è {target_name}{period_str} ÏõåÎìúÌÅ¥ÎùºÏö∞Îìú ÏÉùÏÑ± ÏãúÏûë")
            
            if not keywords:
                self.logger.warning("‚ö†Ô∏è ÌÇ§ÏõåÎìúÍ∞Ä ÏóÜÏñ¥ ÏõåÎìúÌÅ¥ÎùºÏö∞ÎìúÎ•º ÏÉùÏÑ±Ìï† Ïàò ÏóÜÏäµÎãàÎã§.")
                return None
            
            # ÌÇ§ÏõåÎìú ÎîïÏÖîÎÑàÎ¶¨ ÏÉùÏÑ± (Î∂àÏö©Ïñ¥ Ïû¨ÌïÑÌÑ∞ÎßÅ)
            filtered_keywords = []
            for word, freq in keywords:
                if (word not in self.config.KOREAN_STOPWORDS and 
                    len(word) > 1 and 
                    not word.isdigit() and
                    freq >= 2):  # ÏµúÏÜå ÎπàÎèÑ 2 Ïù¥ÏÉÅ
                    filtered_keywords.append((word, freq))
            
            if len(filtered_keywords) < 5:
                self.logger.warning("‚ö†Ô∏è ÌïÑÌÑ∞ÎßÅ ÌõÑ ÌÇ§ÏõåÎìúÍ∞Ä ÎÑàÎ¨¥ Ï†ÅÏäµÎãàÎã§.")
                return None
            
            # ÏÉÅÏúÑ ÌÇ§ÏõåÎìúÎßå ÏÇ¨Ïö©
            word_freq = dict(filtered_keywords[:self.config.WORDCLOUD['max_words']])
            
            # ÏõåÎìúÌÅ¥ÎùºÏö∞Îìú ÏÑ§Ï†ï
            wordcloud_config = self.config.WORDCLOUD
            
            # Ìè∞Ìä∏ Í≤ΩÎ°ú Í≤ÄÏ¶ù Î∞è ÏÑ§Ï†ï
            font_path_to_use = None
            
            # 1. Í∏∞Î≥∏ ÏÑ§Ï†ïÎêú Ìè∞Ìä∏ Í≤ΩÎ°ú ÌôïÏù∏
            if hasattr(self, 'korean_font_path') and self.korean_font_path and os.path.exists(self.korean_font_path):
                if self.korean_font_path.endswith('.ttf'):
                    font_path_to_use = self.korean_font_path
                    self.logger.info(f"üìù ÏõåÎìúÌÅ¥ÎùºÏö∞Îìú Ìè∞Ìä∏ ÏÇ¨Ïö©: {font_path_to_use}")
                else:
                    self.logger.warning(f"‚ö†Ô∏è ÏõåÎìúÌÅ¥ÎùºÏö∞ÎìúÎäî .ttf ÌååÏùºÎßå ÏßÄÏõêÌï©ÎãàÎã§: {self.korean_font_path}")
            
            # 2. ÏãúÏä§ÌÖú Ìè∞Ìä∏ Í≤ΩÎ°úÏóêÏÑú ÌïúÍ∏Ä Ìè∞Ìä∏ Ï∞æÍ∏∞
            if not font_path_to_use:
                import matplotlib.font_manager as fm
                
                # ÌïúÍ∏Ä Ìè∞Ìä∏ Ïù¥Î¶Ñ Î™©Î°ù
                korean_font_names = [
                    'AppleGothic', 'Apple SD Gothic Neo', 'Noto Sans CJK KR',
                    'Malgun Gothic', 'NanumGothic', 'Arial Unicode MS',
                    'Gulim', 'Dotum', 'Batang'
                ]
                
                # ÏãúÏä§ÌÖúÏóêÏÑú ÏÇ¨Ïö© Í∞ÄÎä•Ìïú .ttf Ìè∞Ìä∏ Ï∞æÍ∏∞
                for font_obj in fm.fontManager.ttflist:
                    if (font_obj.name in korean_font_names and 
                        font_obj.fname.endswith('.ttf') and 
                        os.path.exists(font_obj.fname)):
                        font_path_to_use = font_obj.fname
                        self.logger.info(f"üìù ÏãúÏä§ÌÖú ÌïúÍ∏Ä Ìè∞Ìä∏ Î∞úÍ≤¨: {font_obj.name} ({font_path_to_use})")
                        break
            
            # 3. ÎåÄÏ≤¥ Ìè∞Ìä∏ Í≤ΩÎ°ú ÏãúÎèÑ (macOS Í∏∞Ï§Ä)
            if not font_path_to_use:
                alternative_fonts = [
                    '/System/Library/Fonts/Supplemental/AppleGothic.ttf',
                    '/System/Library/Fonts/Supplemental/AppleMyungjo.ttf',
                    '/System/Library/Fonts/Helvetica.ttc',  # Í∏∞Î≥∏ Ìè∞Ìä∏
                    '/System/Library/Fonts/Arial.ttf'
                ]
                
                for alt_font in alternative_fonts:
                    if os.path.exists(alt_font) and alt_font.endswith('.ttf'):
                        font_path_to_use = alt_font
                        self.logger.info(f"üìù ÎåÄÏ≤¥ Ìè∞Ìä∏ ÏÇ¨Ïö©: {font_path_to_use}")
                        break
            
            if not font_path_to_use:
                self.logger.warning("‚ö†Ô∏è ÌïúÍ∏Ä Ìè∞Ìä∏Î•º Ï∞æÏùÑ Ïàò ÏóÜÏñ¥ Í∏∞Î≥∏ Ìè∞Ìä∏Î•º ÏÇ¨Ïö©Ìï©ÎãàÎã§.")
            
            # ÏõåÎìúÌÅ¥ÎùºÏö∞Îìú ÏÉùÏÑ± - config ÏÑ§Ï†ï ÏÇ¨Ïö©
            wordcloud_params = {
                'width': wordcloud_config['width'],
                'height': wordcloud_config['height'],
                'max_words': wordcloud_config['max_words'],
                'min_font_size': wordcloud_config['min_font_size'],
                'max_font_size': wordcloud_config['max_font_size'],
                'background_color': wordcloud_config['background_color'],
                'colormap': wordcloud_config['colormap'],
                'prefer_horizontal': wordcloud_config['prefer_horizontal'],
                'collocations': wordcloud_config['collocations'],
                'relative_scaling': wordcloud_config['relative_scaling']
            }
            
            # Ìè∞Ìä∏ Í≤ΩÎ°úÍ∞Ä ÏûàÏúºÎ©¥ Ï∂îÍ∞Ä
            if font_path_to_use:
                wordcloud_params['font_path'] = font_path_to_use
            
            wordcloud = WordCloud(**wordcloud_params).generate_from_frequencies(word_freq)
            
            # ÏãúÍ∞ÅÌôî
            plt.figure(figsize=(15, 10))
            plt.imshow(wordcloud, interpolation='bilinear')
            plt.axis('off')
            
            title = f'{target_name} Ï£ºÏöî ÌÇ§ÏõåÎìú'
            if period:
                title += f' ({period})'
            plt.title(title, fontsize=20, fontweight='bold', pad=20)
            
            # ÌååÏùº Ï†ÄÏû• (ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ± Ìè¨Ìï®)
            # ÌååÏùºÎ™ÖÏóêÏÑú ÌäπÏàòÎ¨∏Ïûê Ï†úÍ±∞
            safe_period = period.replace('~', '_').replace(' ', '_').replace(':', '_') if period else ""
            filename = f"{target_name}_{safe_period}_wordcloud.png" if safe_period else f"{target_name}_wordcloud.png"
            filepath = os.path.join(self.output_dir, filename)
            
            # ÎîîÎ†âÌÜ†Î¶¨Í∞Ä ÏóÜÏúºÎ©¥ ÏÉùÏÑ±
            os.makedirs(os.path.dirname(filepath), exist_ok=True)
            
            plt.savefig(filepath, dpi=self.config.VISUALIZATION['dpi'], 
                       bbox_inches='tight', facecolor='white')
            plt.close()
            
            self.logger.info(f"‚úÖ ÏõåÎìúÌÅ¥ÎùºÏö∞Îìú ÏÉùÏÑ± ÏôÑÎ£å: {filepath}")
            return filepath
            
        except Exception as e:
            self.logger.error(f"‚ùå ÏõåÎìúÌÅ¥ÎùºÏö∞Îìú ÏÉùÏÑ± Ïã§Ìå®: {str(e)}")
            # Ìè∞Ìä∏ ÏóÜÏù¥ Ïû¨ÏãúÎèÑ
            try:
                self.logger.info("üîÑ Í∏∞Î≥∏ Ìè∞Ìä∏Î°ú ÏõåÎìúÌÅ¥ÎùºÏö∞Îìú Ïû¨ÏãúÎèÑ")
                wordcloud = WordCloud(
                    width=wordcloud_config['width'],
                    height=wordcloud_config['height'],
                    max_words=wordcloud_config['max_words'],
                    background_color=wordcloud_config['background_color'],
                    colormap=wordcloud_config['colormap'],
                    relative_scaling=0.5,
                    min_font_size=10
                ).generate_from_frequencies(word_freq)
                
                plt.figure(figsize=(15, 10))
                plt.imshow(wordcloud, interpolation='bilinear')
                plt.axis('off')
                
                title = f'{target_name} Ï£ºÏöî ÌÇ§ÏõåÎìú'
                if period:
                    title += f' ({period})'
                plt.title(title, fontsize=20, fontweight='bold', pad=20)
                
                # ÌååÏùºÎ™ÖÏóêÏÑú ÌäπÏàòÎ¨∏Ïûê Ï†úÍ±∞
                safe_period = period.replace('~', '_').replace(' ', '_').replace(':', '_') if period else ""
                filename = f"{target_name}_{safe_period}_wordcloud.png" if safe_period else f"{target_name}_wordcloud.png"
                filepath = os.path.join(self.output_dir, filename)
                
                # ÎîîÎ†âÌÜ†Î¶¨Í∞Ä ÏóÜÏúºÎ©¥ ÏÉùÏÑ±
                os.makedirs(os.path.dirname(filepath), exist_ok=True)
                
                plt.savefig(filepath, dpi=self.config.VISUALIZATION['dpi'], 
                           bbox_inches='tight', facecolor='white')
                plt.close()
                
                self.logger.info(f"‚úÖ Í∏∞Î≥∏ Ìè∞Ìä∏Î°ú ÏõåÎìúÌÅ¥ÎùºÏö∞Îìú ÏÉùÏÑ± ÏôÑÎ£å: {filepath}")
                return filepath
                
            except Exception as e2:
                self.logger.error(f"‚ùå Í∏∞Î≥∏ Ìè∞Ìä∏Î°úÎèÑ ÏõåÎìúÌÅ¥ÎùºÏö∞Îìú ÏÉùÏÑ± Ïã§Ìå®: {str(e2)}")
                return None
    
    def plot_time_grouped_comparison(self, time_group_results: Dict, target_name: str, time_unit: str) -> str:
        """
        Ï†ÅÏùëÏ†Å ÏãúÍ∞Ñ Í∑∏Î£πÎ≥Ñ ÎπÑÍµê ÏãúÍ∞ÅÌôî
        Args:
            time_group_results: ÏãúÍ∞Ñ Í∑∏Î£πÎ≥Ñ Î∂ÑÏÑù Í≤∞Í≥º
            target_name: Î∂ÑÏÑù ÎåÄÏÉÅ Ïù¥Î¶Ñ
            time_unit: ÏãúÍ∞Ñ Îã®ÏúÑ (monthly, weekly, hybrid Îì±)
        Returns:
            Ï†ÄÏû•Îêú ÌååÏùº Í≤ΩÎ°ú
        """
        try:
            self.logger.info(f"üìä {target_name} ÏãúÍ∞Ñ Í∑∏Î£πÎ≥Ñ ÎπÑÍµê ÏãúÍ∞ÅÌôî ÏÉùÏÑ± ÏãúÏûë")
            
            # Ìè∞Ìä∏ ÏÑ§Ï†ï Ïû¨Ï†ÅÏö©
            self._apply_font_settings()
            
            # Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ
            periods = []
            positive_ratios = []
            negative_ratios = []
            comment_counts = []
            dominant_emotions = []
            
            for period, result in time_group_results.items():
                periods.append(period)
                
                binary_sentiment = result.get('binary_sentiment', {})
                positive_ratios.append(binary_sentiment.get('positive_ratio', 0) * 100)
                negative_ratios.append(binary_sentiment.get('negative_ratio', 0) * 100)
                comment_counts.append(result.get('total_comments', 0))
                
                emotion_sentiment = result.get('emotion_sentiment', {})
                dominant_emotions.append(emotion_sentiment.get('dominant_emotion', 'ÏóÜÏùå'))
            
            if not periods:
                self.logger.warning("‚ö†Ô∏è ÏãúÍ∞ÅÌôîÌï† Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.")
                return None
            
            # Í∑∏ÎûòÌîÑ ÏÉùÏÑ±
            fig, axes = plt.subplots(2, 2, figsize=(16, 12))
            fig.suptitle(f'{target_name} - ÏãúÍ∞Ñ Í∑∏Î£πÎ≥Ñ Í∞êÏÑ± Î∂ÑÏÑù ÎπÑÍµê ({time_unit})', 
                        fontsize=16, fontweight='bold')
            
            # 1. Í∞êÏÑ± ÎπÑÏú® Ìä∏Î†åÎìú
            x_pos = range(len(periods))
            width = 0.35
            
            axes[0, 0].bar([x - width/2 for x in x_pos], positive_ratios, width, 
                          label='Í∏çÏ†ï', color='skyblue', alpha=0.8)
            axes[0, 0].bar([x + width/2 for x in x_pos], negative_ratios, width, 
                          label='Î∂ÄÏ†ï', color='lightcoral', alpha=0.8)
            
            axes[0, 0].set_title('ÏãúÍ∞Ñ Í∑∏Î£πÎ≥Ñ Í∞êÏÑ± ÎπÑÏú®')
            axes[0, 0].set_xlabel('ÏãúÍ∞Ñ Í∑∏Î£π')
            axes[0, 0].set_ylabel('ÎπÑÏú® (%)')
            axes[0, 0].legend()
            axes[0, 0].set_xticks(x_pos)
            axes[0, 0].set_xticklabels(periods, rotation=45, ha='right')
            axes[0, 0].grid(True, alpha=0.3)
            
            # 2. ÎåìÍ∏Ä Ïàò Ìä∏Î†åÎìú
            axes[0, 1].plot(x_pos, comment_counts, marker='o', linewidth=2, markersize=6, color='green')
            axes[0, 1].set_title('ÏãúÍ∞Ñ Í∑∏Î£πÎ≥Ñ ÎåìÍ∏Ä Ïàò')
            axes[0, 1].set_xlabel('ÏãúÍ∞Ñ Í∑∏Î£π')
            axes[0, 1].set_ylabel('ÎåìÍ∏Ä Ïàò')
            axes[0, 1].set_xticks(x_pos)
            axes[0, 1].set_xticklabels(periods, rotation=45, ha='right')
            axes[0, 1].grid(True, alpha=0.3)
            
            # 3. Ï£ºÏöî Í∞êÏ†ï Î∂ÑÌè¨
            emotion_counts = Counter(dominant_emotions)
            emotions = list(emotion_counts.keys())
            counts = list(emotion_counts.values())
            
            colors = plt.cm.Set3(np.linspace(0, 1, len(emotions)))
            axes[1, 0].pie(counts, labels=emotions, autopct='%1.1f%%', colors=colors, startangle=90)
            axes[1, 0].set_title('Ï£ºÏöî Í∞êÏ†ï Î∂ÑÌè¨')
            
            # 4. Í∞êÏÑ± Ï†êÏàò ÌûàÌä∏Îßµ
            if len(periods) > 1:
                heatmap_data = []
                for period in periods:
                    result = time_group_results[period]
                    binary_sentiment = result.get('binary_sentiment', {})
                    emotion_sentiment = result.get('emotion_sentiment', {})
                    
                    row = [
                        binary_sentiment.get('positive_ratio', 0),
                        binary_sentiment.get('negative_ratio', 0),
                        emotion_sentiment.get('avg_confidence', 0)
                    ]
                    heatmap_data.append(row)
                
                heatmap_df = pd.DataFrame(heatmap_data, 
                                        index=periods, 
                                        columns=['Í∏çÏ†ïÎπÑÏú®', 'Î∂ÄÏ†ïÎπÑÏú®', 'Í∞êÏ†ïÏã†Î¢∞ÎèÑ'])
                
                im = axes[1, 1].imshow(heatmap_df.T, cmap='RdYlBu_r', aspect='auto')
                axes[1, 1].set_title('Í∞êÏÑ± Ï†êÏàò ÌûàÌä∏Îßµ')
                axes[1, 1].set_xticks(range(len(periods)))
                axes[1, 1].set_xticklabels(periods, rotation=45, ha='right')
                axes[1, 1].set_yticks(range(len(heatmap_df.columns)))
                axes[1, 1].set_yticklabels(heatmap_df.columns)
                
                # Ïª¨Îü¨Î∞î Ï∂îÍ∞Ä
                plt.colorbar(im, ax=axes[1, 1])
            else:
                axes[1, 1].text(0.5, 0.5, 'Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±\n(ÌûàÌä∏Îßµ ÏÉùÏÑ± Î∂àÍ∞Ä)', 
                               ha='center', va='center', transform=axes[1, 1].transAxes)
                axes[1, 1].set_title('Í∞êÏÑ± Ï†êÏàò ÌûàÌä∏Îßµ')
            
            plt.tight_layout()
            
            # Ï†ÄÏû•
            filename = f'{target_name}_{time_unit}_comparison.png'
            filepath = os.path.join(self.output_dir, filename)
            plt.savefig(filepath, dpi=300, bbox_inches='tight')
            plt.close()
            
            self.logger.info(f"‚úÖ ÏãúÍ∞Ñ Í∑∏Î£πÎ≥Ñ ÎπÑÍµê ÏãúÍ∞ÅÌôî Ï†ÄÏû•: {filepath}")
            return filepath
            
        except Exception as e:
            self.logger.error(f"‚ùå ÏãúÍ∞Ñ Í∑∏Î£πÎ≥Ñ ÎπÑÍµê ÏãúÍ∞ÅÌôî Ïã§Ìå®: {str(e)}")
            return None
    
    def plot_monthly_comparison(self, monthly_data: Dict, target_name: str) -> str:
        """
        ÏõîÎ≥Ñ ÎπÑÍµê ÏãúÍ∞ÅÌôî (Í∞úÏÑ†Îêú Î≤ÑÏ†Ñ)
        Args:
            monthly_data: ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞
            target_name: Î∂ÑÏÑù ÎåÄÏÉÅ Ïù¥Î¶Ñ
        Returns:
            Ï†ÄÏû•Îêú ÌååÏùº Í≤ΩÎ°ú
        """
        try:
            self.logger.info(f"üìä {target_name} ÏõîÎ≥Ñ ÎπÑÍµê ÏãúÍ∞ÅÌôî ÏãúÏûë")
            
            # Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ
            months = sorted(monthly_data.keys())
            comment_counts = [monthly_data[month]['total_comments'] for month in months]
            
            # Í∞êÏÑ± Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
            positive_ratios = []
            negative_ratios = []
            dominant_emotions = []
            emotion_distributions = {}  # 6Í∞êÏ†ï Î∂ÑÌè¨ Ï†ÄÏû•
            
            for month in months:
                if 'binary_sentiment' in monthly_data[month]:
                    binary_data = monthly_data[month]['binary_sentiment']
                    positive_ratios.append(binary_data.get('positive_ratio', 0))
                    negative_ratios.append(binary_data.get('negative_ratio', 0))
                else:
                    positive_ratios.append(0)
                    negative_ratios.append(0)
                
                if 'emotion_sentiment' in monthly_data[month]:
                    emotion_data = monthly_data[month]['emotion_sentiment']
                    dominant_emotions.append(emotion_data.get('dominant_emotion', 'ÏóÜÏùå'))
                    
                    # 6Í∞êÏ†ï Î∂ÑÌè¨ ÏàòÏßë
                    emotion_dist = emotion_data.get('emotion_distribution', {})
                    for emotion, ratio in emotion_dist.items():
                        if emotion not in emotion_distributions:
                            emotion_distributions[emotion] = []
                        emotion_distributions[emotion].append(ratio)
                else:
                    dominant_emotions.append('ÏóÜÏùå')
                    for emotion in ['Î∂ÑÎÖ∏', 'Ïä¨Ìîî', 'Î∂àÏïà', 'ÏÉÅÏ≤ò', 'ÎãπÌô©', 'Í∏∞ÏÅ®']:
                        if emotion not in emotion_distributions:
                            emotion_distributions[emotion] = []
                        emotion_distributions[emotion].append(0)
            
            # ÏãúÍ∞ÅÌôî (2x2 Î†àÏù¥ÏïÑÏõÉ)
            fig, axes = plt.subplots(2, 2, figsize=(20, 15))
            fig.suptitle(f'{target_name} ÏõîÎ≥Ñ Ï¢ÖÌï© Î∂ÑÏÑù', fontsize=20, fontweight='bold')
            
            # 1. ÏõîÎ≥Ñ ÎåìÍ∏Ä Ïàò + Í∏âÏ¶ù ÏãúÏ†ê ÌëúÏãú
            bars1 = axes[0, 0].bar(months, comment_counts, color='skyblue', alpha=0.7)
            axes[0, 0].set_title('ÏõîÎ≥Ñ ÎåìÍ∏Ä Ïàò Î∞è Í∏âÏ¶ù ÏãúÏ†ê', fontsize=16, fontweight='bold')
            axes[0, 0].set_ylabel('ÎåìÍ∏Ä Ïàò', fontsize=14)
            axes[0, 0].tick_params(axis='x', rotation=45)
            
            # Í∏âÏ¶ù ÏãúÏ†ê ÌëúÏãú (ÌèâÍ∑†Ïùò 1.5Î∞∞ Ïù¥ÏÉÅ)
            avg_comments = np.mean(comment_counts)
            for i, (month, count) in enumerate(zip(months, comment_counts)):
                if count > avg_comments * 1.5:
                    axes[0, 0].annotate('Í∏âÏ¶ù', xy=(i, count), xytext=(i, count + max(comment_counts)*0.1),
                                       arrowprops=dict(arrowstyle='->', color='red', lw=2),
                                       fontsize=12, ha='center', color='red', fontweight='bold')
            
            # ÎßâÎåÄ ÏúÑÏóê Í∞í ÌëúÏãú
            for bar, count in zip(bars1, comment_counts):
                axes[0, 0].text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(comment_counts)*0.01,
                               f'{count:,}', ha='center', va='bottom', fontsize=10)
            
            # 2. Í∞êÏÑ± ÎπÑÏú® Ïä§ÌÉù Î∞î (Í∏∞Ï°¥ Ïú†ÏßÄ)
            width = 0.6
            axes[0, 1].bar(months, positive_ratios, width, label='Í∏çÏ†ï', 
                          color='#2E8B57', alpha=0.8)
            axes[0, 1].bar(months, negative_ratios, width, bottom=positive_ratios, 
                          label='Î∂ÄÏ†ï', color='#DC143C', alpha=0.8)
            axes[0, 1].set_title('ÏõîÎ≥Ñ Í∞êÏÑ± ÎπÑÏú®', fontsize=16, fontweight='bold')
            axes[0, 1].set_ylabel('ÎπÑÏú®', fontsize=14)
            axes[0, 1].legend(fontsize=12)
            axes[0, 1].tick_params(axis='x', rotation=45)
            
            # 3. Ï£ºÏöî Í∞êÏ†ï Î∂ÑÌè¨ (Í∏∞Ï°¥ Ïú†ÏßÄ)
            emotion_counts = Counter(dominant_emotions)
            emotions = list(emotion_counts.keys())
            counts = list(emotion_counts.values())
            
            colors = plt.cm.Set3(np.linspace(0, 1, len(emotions)))
            axes[1, 0].pie(counts, labels=emotions, colors=colors, autopct='%1.1f%%', 
                          startangle=90)
            axes[1, 0].set_title('Ï£ºÏöî Í∞êÏ†ï Î∂ÑÌè¨', fontsize=16, fontweight='bold')
            
            # 4. 6Í∞êÏ†ï ÏõîÎ≥Ñ Î≥ÄÌôî Ï∂îÏù¥ (ÏÉàÎ°ú Ï∂îÍ∞Ä)
            emotion_colors = {
                'Î∂ÑÎÖ∏': '#FF4444', 'Ïä¨Ìîî': '#4444FF', 'Î∂àÏïà': '#FF8800',
                'ÏÉÅÏ≤ò': '#8800FF', 'ÎãπÌô©': '#00FF88', 'Í∏∞ÏÅ®': '#FFFF00'
            }
            
            for emotion, values in emotion_distributions.items():
                if len(values) == len(months) and max(values) > 0.05:  # 5% Ïù¥ÏÉÅÏù∏ Í∞êÏ†ïÎßå ÌëúÏãú
                    axes[1, 1].plot(months, values, marker='o', linewidth=2, 
                                   label=emotion, color=emotion_colors.get(emotion, '#888888'),
                                   markersize=6, alpha=0.8)
            
            axes[1, 1].set_title('6Í∞êÏ†ï ÏõîÎ≥Ñ Î≥ÄÌôî Ï∂îÏù¥', fontsize=16, fontweight='bold')
            axes[1, 1].set_ylabel('Í∞êÏ†ï ÎπÑÏú®', fontsize=14)
            axes[1, 1].legend(fontsize=10, loc='upper right')
            axes[1, 1].tick_params(axis='x', rotation=45)
            axes[1, 1].grid(True, alpha=0.3)
            axes[1, 1].set_ylim(0, max([max(values) for values in emotion_distributions.values()]) * 1.1)
            
            plt.tight_layout()
            
            # ÌååÏùº Ï†ÄÏû•
            filename = f"{target_name}_monthly_comparison.png"
            filepath = os.path.join(self.output_dir, filename)
            plt.savefig(filepath, dpi=self.config.VISUALIZATION['dpi'], 
                       bbox_inches='tight', facecolor='white')
            plt.close()
            
            self.logger.info(f"‚úÖ ÏõîÎ≥Ñ ÎπÑÍµê ÏãúÍ∞ÅÌôî ÏôÑÎ£å: {filepath}")
            return filepath
            
        except Exception as e:
            self.logger.error(f"‚ùå ÏõîÎ≥Ñ ÎπÑÍµê ÏãúÍ∞ÅÌôî Ïã§Ìå®: {str(e)}")
            raise
    
    def create_network_graph(self, monthly_keywords: Dict[str, List[Tuple[str, int]]], 
                           target_name: str) -> List[str]:
        """
        ÏõîÎ≥Ñ ÌÇ§ÏõåÎìú ÎÑ§Ìä∏ÏõåÌÅ¨ Í∑∏ÎûòÌîÑ ÏÉùÏÑ± (Í∞úÏÑ†Îêú Î≤ÑÏ†Ñ)
        Args:
            monthly_keywords: ÏõîÎ≥Ñ ÌÇ§ÏõåÎìú ÎîïÏÖîÎÑàÎ¶¨
            target_name: Î∂ÑÏÑù ÎåÄÏÉÅ Ïù¥Î¶Ñ
        Returns:
            Ï†ÄÏû•Îêú ÌååÏùº Í≤ΩÎ°ú Î¶¨Ïä§Ìä∏
        """
        try:
            self.logger.info(f"üï∏Ô∏è {target_name} ÏõîÎ≥Ñ ÎÑ§Ìä∏ÏõåÌÅ¨ Í∑∏ÎûòÌîÑ ÏÉùÏÑ± ÏãúÏûë")
            
            saved_files = []
            
            for month, keywords in monthly_keywords.items():
                if len(keywords) < 8:  # ÏµúÏÜå ÌÇ§ÏõåÎìú Ïàò Ï¶ùÍ∞Ä
                    self.logger.warning(f"‚ö†Ô∏è {month}: ÌÇ§ÏõåÎìúÍ∞Ä ÎÑàÎ¨¥ Ï†ÅÏñ¥ ÎÑ§Ìä∏ÏõåÌÅ¨ Í∑∏ÎûòÌîÑÎ•º ÏÉùÏÑ±Ìï† Ïàò ÏóÜÏäµÎãàÎã§.")
                    continue
                
                # ÏÉÅÏúÑ ÌÇ§ÏõåÎìúÎßå ÏÇ¨Ïö© (Ïàò Í∞êÏÜå)
                top_keywords = keywords[:12]  # 20Í∞úÏóêÏÑú 12Í∞úÎ°ú Í∞êÏÜå
                
                # ÎÑ§Ìä∏ÏõåÌÅ¨ Í∑∏ÎûòÌîÑ ÏÉùÏÑ±
                G = nx.Graph()
                
                # ÎÖ∏Îìú Ï∂îÍ∞Ä (ÌÇ§ÏõåÎìú)
                for word, freq in top_keywords:
                    # Î∂àÏö©Ïñ¥ Ïû¨ÌôïÏù∏
                    if word not in self.config.KOREAN_STOPWORDS and len(word) > 1:
                        G.add_node(word, weight=freq)
                
                # Ïã§Ï†ú ÎÖ∏Îìú Ïàò ÌôïÏù∏
                if len(G.nodes()) < 5:
                    self.logger.warning(f"‚ö†Ô∏è {month}: Ïú†Ìö®Ìïú ÎÖ∏ÎìúÍ∞Ä ÎÑàÎ¨¥ Ï†ÅÏäµÎãàÎã§.")
                    continue
                
                # Ïó£ÏßÄ Ï∂îÍ∞Ä (ÎπàÎèÑ Í∏∞Î∞ò Ïó∞Í≤∞)
                nodes = list(G.nodes())
                node_weights = {node: G.nodes[node]['weight'] for node in nodes}
                
                # ÎπàÎèÑÍ∞Ä ÎÜíÏùÄ ÎÖ∏ÎìúÎì§ÏùÑ Ï§ëÏã¨ÏúºÎ°ú Ïó∞Í≤∞
                sorted_nodes = sorted(nodes, key=lambda x: node_weights[x], reverse=True)
                
                # Ï§ëÏã¨ ÎÖ∏ÎìúÎì§ (ÏÉÅÏúÑ 3Í∞ú)Í≥º Îã§Î•∏ ÎÖ∏ÎìúÎì§ Ïó∞Í≤∞
                center_nodes = sorted_nodes[:3]
                for center in center_nodes:
                    for other in sorted_nodes[3:]:
                        # ÎπàÎèÑ Ï∞®Ïù¥Í∞Ä ÌÅ¨ÏßÄ ÏïäÏúºÎ©¥ Ïó∞Í≤∞
                        if node_weights[other] >= node_weights[center] * 0.3:
                            G.add_edge(center, other)
                
                # ÎπÑÏä∑Ìïú ÎπàÎèÑÏùò ÎÖ∏ÎìúÎì§ÎÅºÎ¶¨ Ïó∞Í≤∞
                for i in range(len(sorted_nodes)):
                    for j in range(i+1, min(i+3, len(sorted_nodes))):
                        if abs(node_weights[sorted_nodes[i]] - node_weights[sorted_nodes[j]]) <= 2:
                            G.add_edge(sorted_nodes[i], sorted_nodes[j])
                
                # ÏãúÍ∞ÅÌôî
                plt.figure(figsize=(12, 10))
                
                # Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï (Îçî ÏßëÏ§ëÎêú Î†àÏù¥ÏïÑÏõÉ)
                pos = nx.spring_layout(G, k=2, iterations=100, seed=42)
                
                # ÎÖ∏Îìú ÌÅ¨Í∏∞ (ÎπàÎèÑÏóê ÎπÑÎ°Ä, ÌÅ¨Í∏∞ Ï°∞Ï†ï)
                node_sizes = [node_weights[node] * 100 for node in G.nodes()]
                
                # ÎÖ∏Îìú ÏÉâÏÉÅ (ÎπàÎèÑÏóê Îî∞Îùº)
                node_colors = [node_weights[node] for node in G.nodes()]
                
                # ÎÖ∏Îìú Í∑∏Î¶¨Í∏∞
                nodes = nx.draw_networkx_nodes(G, pos, node_size=node_sizes, 
                                             node_color=node_colors, 
                                             cmap=plt.cm.viridis, alpha=0.8)
                
                # Ïó£ÏßÄ Í∑∏Î¶¨Í∏∞ (Îçî ÏñáÍ≤å)
                nx.draw_networkx_edges(G, pos, alpha=0.3, edge_color='gray', width=0.5)
                
                # ÎùºÎ≤® Í∑∏Î¶¨Í∏∞ - ÌïúÍ∏Ä Ìè∞Ìä∏ Ï†ÅÏö©
                label_font = {'size': 9, 'weight': 'bold'}
                if hasattr(self, 'korean_font_name') and self.korean_font_name != "DejaVu Sans":
                    label_font['family'] = self.korean_font_name
                
                nx.draw_networkx_labels(G, pos, font_size=label_font['size'], 
                                      font_weight=label_font['weight'],
                                      font_family=label_font.get('family', 'DejaVu Sans'))
                
                # Ïª¨Îü¨Î∞î Ï∂îÍ∞Ä
                if nodes:
                    plt.colorbar(nodes, label='ÌÇ§ÏõåÎìú ÎπàÎèÑ')
                
                plt.title(f'{target_name} ÌÇ§ÏõåÎìú ÎÑ§Ìä∏ÏõåÌÅ¨ - {month}', 
                         fontsize=14, fontweight='bold')
                plt.axis('off')
                
                # ÌååÏùº Ï†ÄÏû•
                filename = f"{target_name}_network_{month}.png"
                filepath = os.path.join(self.output_dir, filename)
                plt.savefig(filepath, dpi=self.config.VISUALIZATION['dpi'], 
                           bbox_inches='tight', facecolor='white')
                plt.close()
                
                saved_files.append(filepath)
                self.logger.info(f"‚úÖ {month} ÎÑ§Ìä∏ÏõåÌÅ¨ Í∑∏ÎûòÌîÑ ÏÉùÏÑ± ÏôÑÎ£å: {filepath}")
            
            self.logger.info(f"‚úÖ Ï¥ù {len(saved_files)}Í∞ú ÏõîÎ≥Ñ ÎÑ§Ìä∏ÏõåÌÅ¨ Í∑∏ÎûòÌîÑ ÏÉùÏÑ± ÏôÑÎ£å")
            return saved_files
            
        except Exception as e:
            self.logger.error(f"‚ùå ÎÑ§Ìä∏ÏõåÌÅ¨ Í∑∏ÎûòÌîÑ ÏÉùÏÑ± Ïã§Ìå®: {str(e)}")
            return []
    
    def create_interactive_dashboard(self, all_results: Dict, target_name: str) -> str:
        """
        Ïù∏ÌÑ∞ÎûôÌã∞Î∏å ÎåÄÏãúÎ≥¥Îìú ÏÉùÏÑ± (Plotly)
        Args:
            all_results: Î™®Îì† Î∂ÑÏÑù Í≤∞Í≥º
            target_name: Î∂ÑÏÑù ÎåÄÏÉÅ Ïù¥Î¶Ñ
        Returns:
            Ï†ÄÏû•Îêú HTML ÌååÏùº Í≤ΩÎ°ú
        """
        try:
            self.logger.info(f"üì± {target_name} Ïù∏ÌÑ∞ÎûôÌã∞Î∏å ÎåÄÏãúÎ≥¥Îìú ÏÉùÏÑ± ÏãúÏûë")
            
            # ÏÑúÎ∏åÌîåÎ°Ø ÏÉùÏÑ±
            fig = make_subplots(
                rows=2, cols=2,
                subplot_titles=('Í∞êÏÑ± Ìä∏Î†åÎìú', 'ÌÜ†ÌîΩ Ïàò Î≥ÄÌôî', 'ÏõîÎ≥Ñ ÎåìÍ∏Ä Ïàò', 'Í∞êÏ†ï Î∂ÑÌè¨'),
                specs=[[{"secondary_y": False}, {"secondary_y": False}],
                       [{"secondary_y": False}, {"type": "pie"}]]
            )
            
            # Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ (ÏòàÏãú)
            months = list(all_results.keys()) if all_results else []
            
            if months:
                # Í∞êÏÑ± Ìä∏Î†åÎìú
                positive_ratios = []
                negative_ratios = []
                comment_counts = []
                
                for month in months:
                    if 'binary_sentiment' in all_results[month]:
                        binary_data = all_results[month]['binary_sentiment']
                        positive_ratios.append(binary_data.get('positive_ratio', 0))
                        negative_ratios.append(binary_data.get('negative_ratio', 0))
                    else:
                        positive_ratios.append(0)
                        negative_ratios.append(0)
                    
                    comment_counts.append(all_results[month].get('total_comments', 0))
                
                # Í∞êÏÑ± Ìä∏Î†åÎìú Ï∂îÍ∞Ä
                fig.add_trace(
                    go.Scatter(x=months, y=positive_ratios, name='Í∏çÏ†ï', 
                              line=dict(color='green', width=3)),
                    row=1, col=1
                )
                fig.add_trace(
                    go.Scatter(x=months, y=negative_ratios, name='Î∂ÄÏ†ï', 
                              line=dict(color='red', width=3)),
                    row=1, col=1
                )
                
                # ÏõîÎ≥Ñ ÎåìÍ∏Ä Ïàò
                fig.add_trace(
                    go.Bar(x=months, y=comment_counts, name='ÎåìÍ∏Ä Ïàò', 
                          marker_color='skyblue'),
                    row=2, col=1
                )
            
            # Î†àÏù¥ÏïÑÏõÉ ÏÑ§Ï†ï
            fig.update_layout(
                title=f'{target_name} Î∂ÑÏÑù ÎåÄÏãúÎ≥¥Îìú',
                height=800,
                showlegend=True
            )
            
            # HTML ÌååÏùºÎ°ú Ï†ÄÏû•
            filename = f"{target_name}_dashboard.html"
            filepath = os.path.join(self.output_dir, filename)
            fig.write_html(filepath)
            
            self.logger.info(f"‚úÖ Ïù∏ÌÑ∞ÎûôÌã∞Î∏å ÎåÄÏãúÎ≥¥Îìú ÏÉùÏÑ± ÏôÑÎ£å: {filepath}")
            return filepath
            
        except Exception as e:
            self.logger.error(f"‚ùå Ïù∏ÌÑ∞ÎûôÌã∞Î∏å ÎåÄÏãúÎ≥¥Îìú ÏÉùÏÑ± Ïã§Ìå®: {str(e)}")
            raise
    
    def plot_topic_quality_analysis(self, monthly_data: Dict, target_name: str) -> str:
        """
        ÌÜ†ÌîΩ ÌíàÏßà Î∂ÑÏÑù ÏãúÍ∞ÅÌôî
        Args:
            monthly_data: ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞
            target_name: Î∂ÑÏÑù ÎåÄÏÉÅ Ïù¥Î¶Ñ
        Returns:
            Ï†ÄÏû•Îêú ÌååÏùº Í≤ΩÎ°ú
        """
        try:
            self.logger.info(f"üìä {target_name} ÌÜ†ÌîΩ ÌíàÏßà Î∂ÑÏÑù ÏãúÍ∞ÅÌôî ÏãúÏûë")
            
            # Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ
            months = sorted(monthly_data.keys())
            bertopic_counts = []
            lda_counts = []
            lda_coherence_scores = []
            lda_quality_scores = []
            
            for month in months:
                # BERTopic ÌÜ†ÌîΩ Ïàò
                if 'bertopic' in monthly_data[month] and monthly_data[month]['bertopic']:
                    bertopic_result = monthly_data[month]['bertopic']
                    bertopic_counts.append(len(bertopic_result.get('topics', [])))
                else:
                    bertopic_counts.append(0)
                
                # LDA ÌÜ†ÌîΩ Ïàò Î∞è ÌíàÏßà ÏßÄÌëú
                if 'lda' in monthly_data[month] and monthly_data[month]['lda']:
                    lda_result = monthly_data[month]['lda']
                    lda_counts.append(lda_result.get('optimal_topic_count', 0))
                    lda_coherence_scores.append(lda_result.get('coherence_score', 0))
                    lda_quality_scores.append(lda_result.get('topic_quality', 0))
                else:
                    lda_counts.append(0)
                    lda_coherence_scores.append(0)
                    lda_quality_scores.append(0)
            
            # ÏãúÍ∞ÅÌôî (2x2 Î†àÏù¥ÏïÑÏõÉ)
            fig, axes = plt.subplots(2, 2, figsize=(20, 15))
            fig.suptitle(f'{target_name} ÌÜ†ÌîΩ Î∂ÑÏÑù ÌíàÏßà ÌèâÍ∞Ä', fontsize=20, fontweight='bold')
            
            # 1. ÏõîÎ≥Ñ ÌÜ†ÌîΩ Ïàò ÎπÑÍµê (BERTopic vs LDA)
            x = np.arange(len(months))
            width = 0.35
            
            bars1 = axes[0, 0].bar(x - width/2, bertopic_counts, width, label='BERTopic', 
                                  color='skyblue', alpha=0.8)
            bars2 = axes[0, 0].bar(x + width/2, lda_counts, width, label='LDA (ÏµúÏ†ÅÌôî)', 
                                  color='lightcoral', alpha=0.8)
            
            axes[0, 0].set_title('ÏõîÎ≥Ñ ÌÜ†ÌîΩ Ïàò ÎπÑÍµê', fontsize=16, fontweight='bold')
            axes[0, 0].set_ylabel('ÌÜ†ÌîΩ Ïàò', fontsize=14)
            axes[0, 0].set_xticks(x)
            axes[0, 0].set_xticklabels(months, rotation=45)
            axes[0, 0].legend()
            axes[0, 0].grid(True, alpha=0.3)
            
            # ÎßâÎåÄ ÏúÑÏóê Í∞í ÌëúÏãú
            for bar in bars1:
                height = bar.get_height()
                if height > 0:
                    axes[0, 0].text(bar.get_x() + bar.get_width()/2, height + 0.1,
                                   f'{int(height)}', ha='center', va='bottom', fontsize=9)
            
            for bar in bars2:
                height = bar.get_height()
                if height > 0:
                    axes[0, 0].text(bar.get_x() + bar.get_width()/2, height + 0.1,
                                   f'{int(height)}', ha='center', va='bottom', fontsize=9)
            
            # 2. LDA ÏùºÍ¥ÄÏÑ± Ï†êÏàò Î≥ÄÌôî
            valid_coherence = [(month, score) for month, score in zip(months, lda_coherence_scores) if score > 0]
            if valid_coherence:
                valid_months, valid_scores = zip(*valid_coherence)
                axes[0, 1].plot(valid_months, valid_scores, marker='o', linewidth=3, 
                               color='green', markersize=8, alpha=0.8)
                axes[0, 1].set_title('LDA ÌÜ†ÌîΩ ÏùºÍ¥ÄÏÑ± Ï†êÏàò Î≥ÄÌôî', fontsize=16, fontweight='bold')
                axes[0, 1].set_ylabel('ÏùºÍ¥ÄÏÑ± Ï†êÏàò', fontsize=14)
                axes[0, 1].tick_params(axis='x', rotation=45)
                axes[0, 1].grid(True, alpha=0.3)
                axes[0, 1].set_ylim(0, max(valid_scores) * 1.1)
            else:
                axes[0, 1].text(0.5, 0.5, 'ÏùºÍ¥ÄÏÑ± Ï†êÏàò Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå', 
                               ha='center', va='center', transform=axes[0, 1].transAxes,
                               fontsize=14)
                axes[0, 1].set_title('LDA ÌÜ†ÌîΩ ÏùºÍ¥ÄÏÑ± Ï†êÏàò Î≥ÄÌôî', fontsize=16, fontweight='bold')
            
            # 3. LDA ÌÜ†ÌîΩ ÌíàÏßà Ï†êÏàò Î≥ÄÌôî
            valid_quality = [(month, score) for month, score in zip(months, lda_quality_scores) if score > 0]
            if valid_quality:
                valid_months, valid_scores = zip(*valid_quality)
                axes[1, 0].plot(valid_months, valid_scores, marker='s', linewidth=3, 
                               color='purple', markersize=8, alpha=0.8)
                axes[1, 0].set_title('LDA ÌÜ†ÌîΩ ÌíàÏßà Ï†êÏàò Î≥ÄÌôî', fontsize=16, fontweight='bold')
                axes[1, 0].set_ylabel('ÌíàÏßà Ï†êÏàò', fontsize=14)
                axes[1, 0].tick_params(axis='x', rotation=45)
                axes[1, 0].grid(True, alpha=0.3)
                axes[1, 0].set_ylim(0, 1)
            else:
                axes[1, 0].text(0.5, 0.5, 'ÌíàÏßà Ï†êÏàò Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå', 
                               ha='center', va='center', transform=axes[1, 0].transAxes,
                               fontsize=14)
                axes[1, 0].set_title('LDA ÌÜ†ÌîΩ ÌíàÏßà Ï†êÏàò Î≥ÄÌôî', fontsize=16, fontweight='bold')
            
            # 4. ÌÜ†ÌîΩ Î∂ÑÏÑù Ìö®Ïú®ÏÑ± (ÎåìÍ∏Ä Ïàò ÎåÄÎπÑ ÌÜ†ÌîΩ Ïàò)
            comment_counts = [monthly_data[month]['total_comments'] for month in months]
            bertopic_efficiency = [topics/max(comments, 1) * 1000 for topics, comments in zip(bertopic_counts, comment_counts)]
            lda_efficiency = [topics/max(comments, 1) * 1000 for topics, comments in zip(lda_counts, comment_counts)]
            
            axes[1, 1].plot(months, bertopic_efficiency, marker='o', linewidth=2, 
                           label='BERTopic', color='skyblue', markersize=6)
            axes[1, 1].plot(months, lda_efficiency, marker='s', linewidth=2, 
                           label='LDA', color='lightcoral', markersize=6)
            axes[1, 1].set_title('ÌÜ†ÌîΩ Î∂ÑÏÑù Ìö®Ïú®ÏÑ± (ÌÜ†ÌîΩÏàò/ÎåìÍ∏ÄÏàò√ó1000)', fontsize=16, fontweight='bold')
            axes[1, 1].set_ylabel('Ìö®Ïú®ÏÑ± ÏßÄÏàò', fontsize=14)
            axes[1, 1].tick_params(axis='x', rotation=45)
            axes[1, 1].legend()
            axes[1, 1].grid(True, alpha=0.3)
            
            plt.tight_layout()
            
            # ÌååÏùº Ï†ÄÏû•
            filename = f"{target_name}_topic_quality_analysis.png"
            filepath = os.path.join(self.output_dir, filename)
            plt.savefig(filepath, dpi=self.config.VISUALIZATION['dpi'], 
                       bbox_inches='tight', facecolor='white')
            plt.close()
            
            self.logger.info(f"‚úÖ ÌÜ†ÌîΩ ÌíàÏßà Î∂ÑÏÑù ÏãúÍ∞ÅÌôî ÏôÑÎ£å: {filepath}")
            return filepath
            
        except Exception as e:
            self.logger.error(f"‚ùå ÌÜ†ÌîΩ ÌíàÏßà Î∂ÑÏÑù ÏãúÍ∞ÅÌôî Ïã§Ìå®: {str(e)}")
            raise
    
    def plot_emotion_intensity_analysis(self, monthly_data: Dict, target_name: str) -> str:
        """
        Í∞êÏ†ï Í∞ïÎèÑ Î∂ÑÏÑù ÏãúÍ∞ÅÌôî
        Args:
            monthly_data: ÏõîÎ≥Ñ Îç∞Ïù¥ÌÑ∞
            target_name: Î∂ÑÏÑù ÎåÄÏÉÅ Ïù¥Î¶Ñ
        Returns:
            Ï†ÄÏû•Îêú ÌååÏùº Í≤ΩÎ°ú
        """
        try:
            self.logger.info(f"üìä {target_name} Í∞êÏ†ï Í∞ïÎèÑ Î∂ÑÏÑù ÏãúÍ∞ÅÌôî ÏãúÏûë")
            
            # Îç∞Ïù¥ÌÑ∞ Ï§ÄÎπÑ
            months = sorted(monthly_data.keys())
            emotion_intensity_data = {}
            emotion_trigger_data = {}
            
            # 6Í∞êÏ†ïÎ≥Ñ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
            emotions = ['Î∂ÑÎÖ∏', 'Ïä¨Ìîî', 'Î∂àÏïà', 'ÏÉÅÏ≤ò', 'ÎãπÌô©', 'Í∏∞ÏÅ®']
            for emotion in emotions:
                emotion_intensity_data[emotion] = []
                emotion_trigger_data[emotion] = []
            
            for month in months:
                if 'emotion_sentiment' in monthly_data[month]:
                    emotion_data = monthly_data[month]['emotion_sentiment']
                    
                    # Í∞êÏ†ï Í∞ïÎèÑ Îç∞Ïù¥ÌÑ∞
                    intensity_data = emotion_data.get('emotion_intensity', {})
                    for emotion in emotions:
                        if emotion in intensity_data:
                            avg_intensity = intensity_data[emotion].get('average_intensity', 0)
                            emotion_intensity_data[emotion].append(avg_intensity)
                        else:
                            emotion_intensity_data[emotion].append(0)
                    
                    # Í∞êÏ†ï Ìä∏Î¶¨Í±∞ Îç∞Ïù¥ÌÑ∞ (ÏÉÅÏúÑ ÌÇ§ÏõåÎìú Ïàò)
                    trigger_data = emotion_data.get('emotion_triggers', {})
                    for emotion in emotions:
                        if emotion in trigger_data:
                            trigger_count = len(trigger_data[emotion])
                            emotion_trigger_data[emotion].append(trigger_count)
                        else:
                            emotion_trigger_data[emotion].append(0)
                else:
                    for emotion in emotions:
                        emotion_intensity_data[emotion].append(0)
                        emotion_trigger_data[emotion].append(0)
            
            # ÏãúÍ∞ÅÌôî (2x2 Î†àÏù¥ÏïÑÏõÉ)
            fig, axes = plt.subplots(2, 2, figsize=(20, 15))
            fig.suptitle(f'{target_name} Í∞êÏ†ï Í∞ïÎèÑ Î∞è Ìä∏Î¶¨Í±∞ Î∂ÑÏÑù', fontsize=20, fontweight='bold')
            
            # Í∞êÏ†ïÎ≥Ñ ÏÉâÏÉÅ
            emotion_colors = {
                'Î∂ÑÎÖ∏': '#FF4444', 'Ïä¨Ìîî': '#4444FF', 'Î∂àÏïà': '#FF8800',
                'ÏÉÅÏ≤ò': '#8800FF', 'ÎãπÌô©': '#00FF88', 'Í∏∞ÏÅ®': '#FFFF00'
            }
            
            # 1. Í∞êÏ†ï Í∞ïÎèÑ Î≥ÄÌôî (Î∂ÄÏ†ï Í∞êÏ†ï)
            negative_emotions = ['Î∂ÑÎÖ∏', 'Ïä¨Ìîî', 'Î∂àÏïà', 'ÏÉÅÏ≤ò', 'ÎãπÌô©']
            for emotion in negative_emotions:
                if max(emotion_intensity_data[emotion]) > 0:
                    axes[0, 0].plot(months, emotion_intensity_data[emotion], 
                                   marker='o', linewidth=2, label=emotion,
                                   color=emotion_colors[emotion], markersize=6, alpha=0.8)
            
            axes[0, 0].set_title('Î∂ÄÏ†ï Í∞êÏ†ï Í∞ïÎèÑ Î≥ÄÌôî', fontsize=16, fontweight='bold')
            axes[0, 0].set_ylabel('ÌèâÍ∑† Í∞ïÎèÑ', fontsize=14)
            axes[0, 0].tick_params(axis='x', rotation=45)
            axes[0, 0].legend(fontsize=10)
            axes[0, 0].grid(True, alpha=0.3)
            
            # 2. Í∏∞ÏÅ® Í∞êÏ†ï Í∞ïÎèÑ Î≥ÄÌôî
            if max(emotion_intensity_data['Í∏∞ÏÅ®']) > 0:
                axes[0, 1].plot(months, emotion_intensity_data['Í∏∞ÏÅ®'], 
                               marker='o', linewidth=3, color=emotion_colors['Í∏∞ÏÅ®'],
                               markersize=8, alpha=0.8)
                axes[0, 1].fill_between(months, emotion_intensity_data['Í∏∞ÏÅ®'], 
                                       alpha=0.3, color=emotion_colors['Í∏∞ÏÅ®'])
            
            axes[0, 1].set_title('Í∏∞ÏÅ® Í∞êÏ†ï Í∞ïÎèÑ Î≥ÄÌôî', fontsize=16, fontweight='bold')
            axes[0, 1].set_ylabel('ÌèâÍ∑† Í∞ïÎèÑ', fontsize=14)
            axes[0, 1].tick_params(axis='x', rotation=45)
            axes[0, 1].grid(True, alpha=0.3)
            
            # 3. Í∞êÏ†ïÎ≥Ñ Ìä∏Î¶¨Í±∞ ÌÇ§ÏõåÎìú Ïàò
            emotion_names = list(emotion_trigger_data.keys())
            avg_triggers = [np.mean(emotion_trigger_data[emotion]) for emotion in emotion_names]
            
            bars = axes[1, 0].bar(emotion_names, avg_triggers, 
                                 color=[emotion_colors[emotion] for emotion in emotion_names],
                                 alpha=0.8)
            axes[1, 0].set_title('Í∞êÏ†ïÎ≥Ñ ÌèâÍ∑† Ìä∏Î¶¨Í±∞ ÌÇ§ÏõåÎìú Ïàò', fontsize=16, fontweight='bold')
            axes[1, 0].set_ylabel('ÌèâÍ∑† ÌÇ§ÏõåÎìú Ïàò', fontsize=14)
            axes[1, 0].tick_params(axis='x', rotation=45)
            
            # ÎßâÎåÄ ÏúÑÏóê Í∞í ÌëúÏãú
            for bar, value in zip(bars, avg_triggers):
                if value > 0:
                    axes[1, 0].text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.1,
                                   f'{value:.1f}', ha='center', va='bottom', fontsize=10)
            
            # 4. Í∞êÏ†ï Í∞ïÎèÑ ÌûàÌä∏Îßµ
            intensity_matrix = []
            for emotion in emotions:
                intensity_matrix.append(emotion_intensity_data[emotion])
            
            intensity_matrix = np.array(intensity_matrix)
            
            if intensity_matrix.max() > 0:
                im = axes[1, 1].imshow(intensity_matrix, cmap='YlOrRd', aspect='auto')
                axes[1, 1].set_title('Í∞êÏ†ï Í∞ïÎèÑ ÌûàÌä∏Îßµ (ÏõîÎ≥Ñ)', fontsize=16, fontweight='bold')
                axes[1, 1].set_ylabel('Í∞êÏ†ï', fontsize=14)
                axes[1, 1].set_xlabel('Ïõî', fontsize=14)
                axes[1, 1].set_yticks(range(len(emotions)))
                axes[1, 1].set_yticklabels(emotions)
                axes[1, 1].set_xticks(range(0, len(months), max(1, len(months)//6)))
                axes[1, 1].set_xticklabels([months[i] for i in range(0, len(months), max(1, len(months)//6))], 
                                          rotation=45)
                
                # Ïª¨Îü¨Î∞î Ï∂îÍ∞Ä
                plt.colorbar(im, ax=axes[1, 1], label='Í∞ïÎèÑ')
            else:
                axes[1, 1].text(0.5, 0.5, 'Í∞êÏ†ï Í∞ïÎèÑ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå', 
                               ha='center', va='center', transform=axes[1, 1].transAxes,
                               fontsize=14)
                axes[1, 1].set_title('Í∞êÏ†ï Í∞ïÎèÑ ÌûàÌä∏Îßµ (ÏõîÎ≥Ñ)', fontsize=16, fontweight='bold')
            
            plt.tight_layout()
            
            # ÌååÏùº Ï†ÄÏû•
            filename = f"{target_name}_emotion_intensity_analysis.png"
            filepath = os.path.join(self.output_dir, filename)
            plt.savefig(filepath, dpi=self.config.VISUALIZATION['dpi'], 
                       bbox_inches='tight', facecolor='white')
            plt.close()
            
            self.logger.info(f"‚úÖ Í∞êÏ†ï Í∞ïÎèÑ Î∂ÑÏÑù ÏãúÍ∞ÅÌôî ÏôÑÎ£å: {filepath}")
            return filepath
            
        except Exception as e:
            self.logger.error(f"‚ùå Í∞êÏ†ï Í∞ïÎèÑ Î∂ÑÏÑù ÏãúÍ∞ÅÌôî Ïã§Ìå®: {str(e)}")
            raise 
    
    def plot_frame_velocity_analysis(self, comprehensive_results: Dict, target_name: str) -> str:
        """
        ÌîÑÎ†àÏûÑ Î≥ÄÌôî ÏÜçÎèÑ Î∂ÑÏÑù ÏãúÍ∞ÅÌôî (Ïó∞Íµ¨ Î™©Ï†Å: Îâ¥Ïä§ vs ÎåÄÏ§ë Î∞òÏùë Ï∞®Ïù¥)
        Args:
            comprehensive_results: Ï¢ÖÌï© Î∂ÑÏÑù Í≤∞Í≥º
            target_name: Î∂ÑÏÑù ÎåÄÏÉÅ Ïù¥Î¶Ñ
        Returns:
            Ï†ÄÏû•Îêú ÌååÏùº Í≤ΩÎ°ú
        """
        try:
            self.logger.info(f"üöÄ {target_name} ÌîÑÎ†àÏûÑ Î≥ÄÌôî ÏÜçÎèÑ Î∂ÑÏÑù ÏãúÍ∞ÅÌôî ÏãúÏûë")
            
            # Ìè∞Ìä∏ ÏÑ§Ï†ï Ïû¨Ï†ÅÏö©
            self._apply_font_settings()
            
            fig, axes = plt.subplots(2, 2, figsize=(20, 15))
            fig.suptitle(f'{target_name} ÌîÑÎ†àÏûÑ Î≥ÄÌôî ÏÜçÎèÑ Î∂ÑÏÑù: Îâ¥Ïä§ vs ÎåÄÏ§ë Îã¥Î°†', fontsize=20, fontweight='bold')
            
            periods = sorted(comprehensive_results.keys())
            
            # 1. ÌÜ†ÌîΩ ÌÇ§ÏõåÎìú Î≥ÄÌôîÏú® (ÏùòÎØ∏Ï†Å ÌîÑÎ†àÏûÑ Î≥ÄÌôî)
            keyword_change_rates = []
            sentiment_change_rates = []
            comment_velocity = []
            topic_diversity_changes = []
            
            prev_keywords = set()
            prev_sentiment = None
            prev_comment_count = 0
            prev_topic_diversity = 0
            
            for i, period in enumerate(periods):
                result = comprehensive_results[period]
                
                # ÌòÑÏû¨ Í∏∞Í∞ÑÏùò ÌÇ§ÏõåÎìú Ï∂îÏ∂ú
                current_keywords = set()
                if 'bertopic' in result and result['bertopic'].get('topic_words'):
                    for topic_words in result['bertopic']['topic_words'].values():
                        if isinstance(topic_words, list):
                            current_keywords.update([word for word, _ in topic_words[:5]])
                
                # ÌÇ§ÏõåÎìú Î≥ÄÌôîÏú® Í≥ÑÏÇ∞ (ÏûêÏπ¥Îìú Í±∞Î¶¨)
                if prev_keywords and current_keywords:
                    intersection = len(prev_keywords & current_keywords)
                    union = len(prev_keywords | current_keywords)
                    jaccard_similarity = intersection / union if union > 0 else 0
                    change_rate = 1 - jaccard_similarity
                else:
                    change_rate = 1.0 if current_keywords else 0.0
                
                keyword_change_rates.append(change_rate)
                
                # Í∞êÏ†ï Î≥ÄÌôîÏú® Í≥ÑÏÇ∞
                current_sentiment = result.get('binary_sentiment', {}).get('positive_ratio', 0.5)
                if prev_sentiment is not None:
                    sentiment_change = abs(current_sentiment - prev_sentiment)
                else:
                    sentiment_change = 0
                sentiment_change_rates.append(sentiment_change)
                
                # ÎåìÍ∏Ä Ïàò Î≥ÄÌôîÏú® (Í¥ÄÏã¨ÎèÑ Í∏âÎ≥Ä)
                current_comment_count = result.get('total_comments', 0)
                if prev_comment_count > 0:
                    comment_change = abs(current_comment_count - prev_comment_count) / prev_comment_count
                else:
                    comment_change = 0
                comment_velocity.append(comment_change)
                
                # ÌÜ†ÌîΩ Îã§ÏñëÏÑ± Î≥ÄÌôî
                current_topic_count = 0
                if 'bertopic' in result and result['bertopic'].get('topic_labels'):
                    current_topic_count = len(result['bertopic']['topic_labels'])
                
                if prev_topic_diversity > 0:
                    diversity_change = abs(current_topic_count - prev_topic_diversity) / max(prev_topic_diversity, 1)
                else:
                    diversity_change = 0
                topic_diversity_changes.append(diversity_change)
                
                # Ïù¥Ï†Ñ Í∞í ÏóÖÎç∞Ïù¥Ìä∏
                prev_keywords = current_keywords
                prev_sentiment = current_sentiment
                prev_comment_count = current_comment_count
                prev_topic_diversity = current_topic_count
            
            # 1. ÌîÑÎ†àÏûÑ Î≥ÄÌôî ÏÜçÎèÑ (ÌÇ§ÏõåÎìú Í∏∞Ï§Ä)
            axes[0, 0].plot(periods, keyword_change_rates, marker='o', linewidth=3, 
                           color='#FF6B6B', markersize=8, alpha=0.8)
            axes[0, 0].set_title('ÏùòÎØ∏Ï†Å ÌîÑÎ†àÏûÑ Î≥ÄÌôî ÏÜçÎèÑ\n(ÌÇ§ÏõåÎìú Î≥ÄÌôîÏú®)', fontsize=16, fontweight='bold')
            axes[0, 0].set_ylabel('Î≥ÄÌôîÏú® (0=ÎèôÏùº, 1=ÏôÑÏ†ÑÎ≥ÄÌôî)', fontsize=14)
            axes[0, 0].tick_params(axis='x', rotation=45)
            axes[0, 0].grid(True, alpha=0.3)
            axes[0, 0].set_ylim(0, 1.1)
            
            # Í∏âÎ≥ÄÏ†ê ÌëúÏãú
            threshold = np.mean(keyword_change_rates) + np.std(keyword_change_rates)
            for i, rate in enumerate(keyword_change_rates):
                if rate > threshold:
                    axes[0, 0].scatter(periods[i], rate, color='red', s=150, alpha=0.8, marker='*')
                    axes[0, 0].text(periods[i], rate + 0.05, 'Í∏âÎ≥Ä', ha='center', va='bottom', 
                                   fontsize=10, fontweight='bold', color='red')
            
            # 2. Í∞êÏ†ï Î≥ÄÌôî ÏÜçÎèÑ vs Í¥ÄÏã¨ÎèÑ Î≥ÄÌôî
            ax2 = axes[0, 1].twinx()
            
            line1 = axes[0, 1].plot(periods, sentiment_change_rates, marker='s', linewidth=3, 
                                   color='#4ECDC4', markersize=8, alpha=0.8, label='Í∞êÏ†ï Î≥ÄÌôîÏú®')
            line2 = ax2.plot(periods, comment_velocity, marker='^', linewidth=3, 
                            color='#45B7D1', markersize=8, alpha=0.8, label='Í¥ÄÏã¨ÎèÑ Î≥ÄÌôîÏú®')
            
            axes[0, 1].set_title('Í∞êÏ†ï vs Í¥ÄÏã¨ÎèÑ Î≥ÄÌôî ÏÜçÎèÑ', fontsize=16, fontweight='bold')
            axes[0, 1].set_ylabel('Í∞êÏ†ï Î≥ÄÌôîÏú®', fontsize=14, color='#4ECDC4')
            ax2.set_ylabel('Í¥ÄÏã¨ÎèÑ Î≥ÄÌôîÏú®', fontsize=14, color='#45B7D1')
            axes[0, 1].tick_params(axis='x', rotation=45)
            axes[0, 1].tick_params(axis='y', labelcolor='#4ECDC4')
            ax2.tick_params(axis='y', labelcolor='#45B7D1')
            axes[0, 1].grid(True, alpha=0.3)
            
            # Î≤îÎ°Ä ÌÜµÌï©
            lines = line1 + line2
            labels = [l.get_label() for l in lines]
            axes[0, 1].legend(lines, labels, loc='upper left')
            
            # 3. ÌîÑÎ†àÏûÑ Î≥ÄÌôî Ìå®ÌÑ¥ Î∂ÑÎ•ò
            # Î≥ÄÌôî Ìå®ÌÑ¥ÏùÑ 4Í∞ÄÏßÄÎ°ú Î∂ÑÎ•ò: ÏïàÏ†ï, Ï†êÏßÑÏ†Å Î≥ÄÌôî, Í∏âÎ≥Ä, ÌòºÎûÄ
            pattern_labels = []
            pattern_colors = []
            
            for i in range(len(periods)):
                keyword_rate = keyword_change_rates[i] if i < len(keyword_change_rates) else 0
                sentiment_rate = sentiment_change_rates[i] if i < len(sentiment_change_rates) else 0
                
                if keyword_rate < 0.3 and sentiment_rate < 0.1:
                    pattern = 'ÏïàÏ†ï'
                    color = '#2ECC71'
                elif keyword_rate < 0.6 and sentiment_rate < 0.2:
                    pattern = 'Ï†êÏßÑÏ†Å Î≥ÄÌôî'
                    color = '#F39C12'
                elif keyword_rate >= 0.6 or sentiment_rate >= 0.2:
                    pattern = 'Í∏âÎ≥Ä'
                    color = '#E74C3C'
                else:
                    pattern = 'ÌòºÎûÄ'
                    color = '#9B59B6'
                
                pattern_labels.append(pattern)
                pattern_colors.append(color)
            
            # Ìå®ÌÑ¥Î≥Ñ ÏÉâÏÉÅÏúºÎ°ú ÎßâÎåÄ Í∑∏ÎûòÌîÑ
            bars = axes[1, 0].bar(periods, [1] * len(periods), color=pattern_colors, alpha=0.8)
            axes[1, 0].set_title('ÌîÑÎ†àÏûÑ Î≥ÄÌôî Ìå®ÌÑ¥ Î∂ÑÎ•ò', fontsize=16, fontweight='bold')
            axes[1, 0].set_ylabel('Ìå®ÌÑ¥ Í∞ïÎèÑ', fontsize=14)
            axes[1, 0].tick_params(axis='x', rotation=45)
            axes[1, 0].set_ylim(0, 1.2)
            
            # Ìå®ÌÑ¥ ÎùºÎ≤® ÌëúÏãú
            for bar, pattern in zip(bars, pattern_labels):
                axes[1, 0].text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.05,
                               pattern, ha='center', va='bottom', fontsize=10, fontweight='bold')
            
            # Î≤îÎ°Ä Ï∂îÍ∞Ä
            unique_patterns = list(set(pattern_labels))
            unique_colors = [pattern_colors[pattern_labels.index(p)] for p in unique_patterns]
            legend_elements = [plt.Rectangle((0,0),1,1, color=color, alpha=0.8) 
                             for color in unique_colors]
            axes[1, 0].legend(legend_elements, unique_patterns, loc='upper right')
            
            # 4. Î≥ÄÌôî ÏÜçÎèÑ Ï¢ÖÌï© ÏßÄÏàò
            # ÌÇ§ÏõåÎìú, Í∞êÏ†ï, Í¥ÄÏã¨ÎèÑ Î≥ÄÌôîÎ•º Ï¢ÖÌï©Ìïú ÏßÄÏàò
            composite_velocity = []
            for i in range(len(periods)):
                keyword_rate = keyword_change_rates[i] if i < len(keyword_change_rates) else 0
                sentiment_rate = sentiment_change_rates[i] if i < len(sentiment_change_rates) else 0
                comment_rate = comment_velocity[i] if i < len(comment_velocity) else 0
                
                # Í∞ÄÏ§ë ÌèâÍ∑† (ÌÇ§ÏõåÎìú Î≥ÄÌôîÏóê Îçî ÎÜíÏùÄ Í∞ÄÏ§ëÏπò)
                composite = (keyword_rate * 0.5 + sentiment_rate * 0.3 + comment_rate * 0.2)
                composite_velocity.append(composite)
            
            axes[1, 1].plot(periods, composite_velocity, marker='o', linewidth=4, 
                           color='#8E44AD', markersize=10, alpha=0.9)
            axes[1, 1].fill_between(periods, composite_velocity, alpha=0.3, color='#8E44AD')
            axes[1, 1].set_title('Ï¢ÖÌï© ÌîÑÎ†àÏûÑ Î≥ÄÌôî ÏßÄÏàò\n(Îâ¥Ïä§ Î∂ÑÏÑùÏúºÎ°úÎäî Ìè¨Ï∞© Î∂àÍ∞ÄÎä•)', fontsize=16, fontweight='bold')
            axes[1, 1].set_ylabel('Ï¢ÖÌï© Î≥ÄÌôî ÏßÄÏàò', fontsize=14)
            axes[1, 1].tick_params(axis='x', rotation=45)
            axes[1, 1].grid(True, alpha=0.3)
            
            # ÌèâÍ∑†ÏÑ† ÌëúÏãú
            avg_velocity = np.mean(composite_velocity)
            axes[1, 1].axhline(y=avg_velocity, color='red', linestyle='--', alpha=0.7, 
                              label=f'ÌèâÍ∑†: {avg_velocity:.3f}')
            axes[1, 1].legend()
            
            # ÏµúÍ≥†Ï†ê ÌëúÏãú
            max_idx = np.argmax(composite_velocity)
            max_value = composite_velocity[max_idx]
            axes[1, 1].annotate(f'ÏµúÎåÄ Î≥ÄÌôî\n{periods[max_idx]}\n({max_value:.3f})', 
                               xy=(periods[max_idx], max_value),
                               xytext=(10, 20), textcoords='offset points',
                               bbox=dict(boxstyle='round,pad=0.5', facecolor='yellow', alpha=0.8),
                               arrowprops=dict(arrowstyle='->', connectionstyle='arc3,rad=0'))
            
            plt.tight_layout()
            
            # ÌååÏùº Ï†ÄÏû•
            filename = f"{target_name}_frame_velocity_analysis.png"
            filepath = os.path.join(self.output_dir, filename)
            
            # ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
            os.makedirs(os.path.dirname(filepath), exist_ok=True)
            
            plt.savefig(filepath, dpi=self.config.VISUALIZATION['dpi'], 
                       bbox_inches='tight', facecolor='white')
            plt.close()
            
            self.logger.info(f"‚úÖ ÌîÑÎ†àÏûÑ Î≥ÄÌôî ÏÜçÎèÑ Î∂ÑÏÑù ÏãúÍ∞ÅÌôî ÏôÑÎ£å: {filepath}")
            return filepath
            
        except Exception as e:
            self.logger.error(f"‚ùå ÌîÑÎ†àÏûÑ Î≥ÄÌôî ÏÜçÎèÑ Î∂ÑÏÑù ÏãúÍ∞ÅÌôî Ïã§Ìå®: {str(e)}")
            raise
    
    def plot_hidden_discourse_analysis(self, comprehensive_results: Dict, target_name: str) -> str:
        """
        Ïà®Í≤®ÏßÑ ÌïòÏúÑ Îã¥Î°† Î∞úÍµ¥ Î∂ÑÏÑù ÏãúÍ∞ÅÌôî (Ïó∞Íµ¨ Î™©Ï†Å: Ï£ºÎ•ò Ïñ∏Î°†ÏóêÏÑú Îã§Î£®ÏßÄ ÏïäÎäî ÎåÄÏ§ë Í¥ÄÏã¨ÏÇ¨)
        Args:
            comprehensive_results: Ï¢ÖÌï© Î∂ÑÏÑù Í≤∞Í≥º
            target_name: Î∂ÑÏÑù ÎåÄÏÉÅ Ïù¥Î¶Ñ
        Returns:
            Ï†ÄÏû•Îêú ÌååÏùº Í≤ΩÎ°ú
        """
        try:
            self.logger.info(f"üîç {target_name} Ïà®Í≤®ÏßÑ ÌïòÏúÑ Îã¥Î°† Î∞úÍµ¥ Î∂ÑÏÑù ÏãúÍ∞ÅÌôî ÏãúÏûë")
            
            # Ìè∞Ìä∏ ÏÑ§Ï†ï Ïû¨Ï†ÅÏö©
            self._apply_font_settings()
            
            fig, axes = plt.subplots(2, 2, figsize=(20, 15))
            fig.suptitle(f'{target_name} Ïà®Í≤®ÏßÑ ÌïòÏúÑ Îã¥Î°† Î∞úÍµ¥: Ïñ∏Î°†Ïù¥ ÎÜìÏπú ÎåÄÏ§ëÏùò Î™©ÏÜåÎ¶¨', fontsize=20, fontweight='bold')
            
            periods = sorted(comprehensive_results.keys())
            
            # 1. ÏÜåÏàò ÏùòÍ≤¨Ïù¥ÏßÄÎßå Í∞ïÌïú Í∞êÏ†ïÏùÑ ÎèôÎ∞òÌïòÎäî ÌÜ†ÌîΩ Î∞úÍµ¥
            minority_topics = {}  # {topic: {periods: [], emotion_intensity: [], comment_ratio: []}}
            emotion_intensity_by_topic = {}
            topic_persistence = {}
            
            for period in periods:
                result = comprehensive_results[period]
                total_comments = result.get('total_comments', 0)
                
                # BERTopicÏóêÏÑú ÏÜåÏàò ÌÜ†ÌîΩ Ï∂îÏ∂ú
                if 'bertopic' in result and result['bertopic'].get('topic_words'):
                    topic_words = result['bertopic']['topic_words']
                    topic_sizes = result['bertopic'].get('topic_sizes', {})
                    
                    for topic_id, words in topic_words.items():
                        if isinstance(words, list) and len(words) > 0:
                            # ÌÜ†ÌîΩ ÎåÄÌëú ÌÇ§ÏõåÎìú (Ï≤´ Î≤àÏß∏ ÌÇ§ÏõåÎìú)
                            topic_key = words[0][0] if isinstance(words[0], tuple) else str(words[0])
                            
                            # ÌÜ†ÌîΩ ÌÅ¨Í∏∞ (Ï†ÑÏ≤¥ ÎåìÍ∏Ä ÎåÄÎπÑ ÎπÑÏú®)
                            topic_size = topic_sizes.get(topic_id, 0)
                            topic_ratio = topic_size / max(total_comments, 1)
                            
                            # ÏÜåÏàò ÌÜ†ÌîΩ Í∏∞Ï§Ä: Ï†ÑÏ≤¥Ïùò 5% ÎØ∏ÎßåÏù¥ÏßÄÎßå Ï°¥Ïû¨ÌïòÎäî ÌÜ†ÌîΩ
                            if 0.01 < topic_ratio < 0.05:
                                if topic_key not in minority_topics:
                                    minority_topics[topic_key] = {
                                        'periods': [],
                                        'ratios': [],
                                        'emotion_scores': [],
                                        'keywords': []
                                    }
                                
                                minority_topics[topic_key]['periods'].append(period)
                                minority_topics[topic_key]['ratios'].append(topic_ratio)
                                
                                # Í∞êÏ†ï Í∞ïÎèÑ Í≥ÑÏÇ∞ (ÏûÑÏùòÎ°ú ÏÑ§Ï†ï, Ïã§Ï†úÎ°úÎäî Ìï¥Îãπ ÌÜ†ÌîΩ ÎåìÍ∏ÄÏùò Í∞êÏ†ï Î∂ÑÏÑù ÌïÑÏöî)
                                emotion_score = topic_ratio * 10  # ÎπÑÏú®Ïóê ÎπÑÎ°ÄÌïú Í∞êÏ†ï Í∞ïÎèÑ
                                minority_topics[topic_key]['emotion_scores'].append(emotion_score)
                                
                                # ÌÇ§ÏõåÎìú Ï†ÄÏû•
                                topic_keywords = [w[0] if isinstance(w, tuple) else str(w) for w in words[:3]]
                                minority_topics[topic_key]['keywords'] = topic_keywords
            
            # ÏÜåÏàò ÏùòÍ≤¨ ÌÜ†ÌîΩÎì§Ïùò Í∞êÏ†ï Í∞ïÎèÑ vs ÏßÄÏÜçÏÑ±
            if minority_topics:
                topic_names = list(minority_topics.keys())[:8]  # ÏÉÅÏúÑ 8Í∞úÎßå ÌëúÏãú
                avg_emotions = []
                persistence_scores = []
                avg_ratios = []
                
                for topic in topic_names:
                    data = minority_topics[topic]
                    avg_emotions.append(np.mean(data['emotion_scores']))
                    persistence_scores.append(len(data['periods']))  # Îì±Ïû• Í∏∞Í∞Ñ Ïàò
                    avg_ratios.append(np.mean(data['ratios']) * 100)  # Î∞±Î∂ÑÏú®Î°ú Î≥ÄÌôò
                
                # Î≤ÑÎ∏î Ï∞®Ìä∏
                scatter = axes[0, 0].scatter(persistence_scores, avg_emotions, s=np.array(avg_ratios)*200, 
                                           alpha=0.6, c=range(len(topic_names)), cmap='viridis')
                
                axes[0, 0].set_title('ÏÜåÏàò ÏùòÍ≤¨ ÌÜ†ÌîΩÏùò ÏßÄÏÜçÏÑ± vs Í∞êÏ†ï Í∞ïÎèÑ', fontsize=16, fontweight='bold')
                axes[0, 0].set_xlabel('ÏßÄÏÜçÏÑ± (Îì±Ïû• Í∏∞Í∞Ñ Ïàò)', fontsize=14)
                axes[0, 0].set_ylabel('ÌèâÍ∑† Í∞êÏ†ï Í∞ïÎèÑ', fontsize=14)
                axes[0, 0].grid(True, alpha=0.3)
                
                # ÌÜ†ÌîΩ ÎùºÎ≤® ÌëúÏãú
                for i, topic in enumerate(topic_names):
                    axes[0, 0].annotate(topic[:8] + '...', 
                                       (persistence_scores[i], avg_emotions[i]),
                                       xytext=(5, 5), textcoords='offset points',
                                       fontsize=9, alpha=0.8)
                
                # Ïª¨Îü¨Î∞î
                plt.colorbar(scatter, ax=axes[0, 0], label='ÌÜ†ÌîΩ Ïù∏Îç±Ïä§')
            else:
                axes[0, 0].text(0.5, 0.5, 'ÏÜåÏàò ÏùòÍ≤¨ ÌÜ†ÌîΩ ÏóÜÏùå', ha='center', va='center', 
                               transform=axes[0, 0].transAxes, fontsize=14)
                axes[0, 0].set_title('ÏÜåÏàò ÏùòÍ≤¨ ÌÜ†ÌîΩÏùò ÏßÄÏÜçÏÑ± vs Í∞êÏ†ï Í∞ïÎèÑ', fontsize=16, fontweight='bold')
            
            # 2. ÏãúÍ∞ÑÎåÄÎ≥Ñ Ïà®Í≤®ÏßÑ Í¥ÄÏã¨ÏÇ¨ Îì±Ïû• Ìå®ÌÑ¥
            hidden_interests = {}
            for period in periods:
                result = comprehensive_results[period]
                
                # Í∞Å Í∏∞Í∞ÑÎ≥ÑÎ°ú ÌäπÏù¥Ìïú ÌÇ§ÏõåÎìú Ï∂îÏ∂ú (Îã§Î•∏ Í∏∞Í∞ÑÏóêÎäî ÏóÜÎäî ÌÇ§ÏõåÎìú)
                current_keywords = set()
                if 'bertopic' in result and result['bertopic'].get('topic_words'):
                    for topic_words in result['bertopic']['topic_words'].values():
                        if isinstance(topic_words, list):
                            current_keywords.update([w[0] if isinstance(w, tuple) else str(w) 
                                                   for w in topic_words[:5]])
                
                # Îã§Î•∏ Í∏∞Í∞ÑÎì§Ïùò ÌÇ§ÏõåÎìú ÏàòÏßë
                other_keywords = set()
                for other_period in periods:
                    if other_period != period:
                        other_result = comprehensive_results[other_period]
                        if 'bertopic' in other_result and other_result['bertopic'].get('topic_words'):
                            for topic_words in other_result['bertopic']['topic_words'].values():
                                if isinstance(topic_words, list):
                                    other_keywords.update([w[0] if isinstance(w, tuple) else str(w) 
                                                         for w in topic_words[:5]])
                
                # ÌòÑÏû¨ Í∏∞Í∞ÑÏóêÎßå Îì±Ïû•ÌïòÎäî ÌÇ§ÏõåÎìú (Ïà®Í≤®ÏßÑ Í¥ÄÏã¨ÏÇ¨)
                unique_keywords = current_keywords - other_keywords
                hidden_interests[period] = len(unique_keywords)
            
            # Ïà®Í≤®ÏßÑ Í¥ÄÏã¨ÏÇ¨ Îì±Ïû• Ìå®ÌÑ¥
            periods_list = list(hidden_interests.keys())
            hidden_counts = list(hidden_interests.values())
            
            bars = axes[0, 1].bar(periods_list, hidden_counts, color='#E67E22', alpha=0.8)
            axes[0, 1].set_title('Í∏∞Í∞ÑÎ≥Ñ Ïà®Í≤®ÏßÑ Í¥ÄÏã¨ÏÇ¨ Îì±Ïû• Ïàò\n(Ìï¥Îãπ Í∏∞Í∞ÑÏóêÎßå ÎÇòÌÉÄÎÇòÎäî ÌÜ†ÌîΩ)', fontsize=16, fontweight='bold')
            axes[0, 1].set_ylabel('Í≥†Ïú† ÌÇ§ÏõåÎìú Ïàò', fontsize=14)
            axes[0, 1].tick_params(axis='x', rotation=45)
            axes[0, 1].grid(True, alpha=0.3)
            
            # Í∞í ÌëúÏãú
            for bar, count in zip(bars, hidden_counts):
                if count > 0:
                    axes[0, 1].text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.1,
                                   str(count), ha='center', va='bottom', fontsize=10)
            
            # 3. Í∞êÏ†ï Í∑πÏÑ±Î≥Ñ ÌïòÏúÑ Îã¥Î°† Î∂ÑÌè¨
            emotion_discourse_map = {
                'Î∂ÑÎÖ∏': [], 'Ïä¨Ìîî': [], 'Î∂àÏïà': [], 'ÏÉÅÏ≤ò': [], 'ÎãπÌô©': [], 'Í∏∞ÏÅ®': []
            }
            
            for period in periods:
                result = comprehensive_results[period]
                
                # Í∞êÏ†ïÎ≥Ñ ÌÜ†ÌîΩ Î∂ÑÌè¨ (Í∞ÄÏÉÅ Îç∞Ïù¥ÌÑ∞ - Ïã§Ï†úÎ°úÎäî Í∞êÏ†ïÎ≥Ñ ÌÜ†ÌîΩ Î∂ÑÏÑù ÌïÑÏöî)
                if 'emotion_sentiment' in result:
                    emotion_dist = result['emotion_sentiment'].get('emotion_distribution', {})
                    
                    for emotion, ratio in emotion_dist.items():
                        if emotion in emotion_discourse_map:
                            emotion_discourse_map[emotion].append(ratio)
                        else:
                            emotion_discourse_map[emotion] = [ratio]
            
            # Í∞êÏ†ïÎ≥Ñ ÌèâÍ∑† ÎπÑÏú® Í≥ÑÏÇ∞
            emotion_names = []
            emotion_ratios = []
            emotion_colors = ['#FF4444', '#4444FF', '#FF8800', '#8800FF', '#00FF88', '#FFFF00']
            
            for emotion, ratios in emotion_discourse_map.items():
                if ratios:
                    emotion_names.append(emotion)
                    emotion_ratios.append(np.mean(ratios))
            
            if emotion_names:
                # ÎèÑÎÑõ Ï∞®Ìä∏
                wedges, texts, autotexts = axes[1, 0].pie(emotion_ratios, labels=emotion_names, 
                                                         colors=emotion_colors[:len(emotion_names)],
                                                         autopct='%1.1f%%', startangle=90,
                                                         wedgeprops=dict(width=0.5))
                axes[1, 0].set_title('Í∞êÏ†ïÎ≥Ñ ÌïòÏúÑ Îã¥Î°† Î∂ÑÌè¨\n(Ïñ∏Î°†ÏóêÏÑú Í∞ÑÍ≥ºÎêú Í∞êÏ†ïÏ†Å Î∞òÏùë)', fontsize=16, fontweight='bold')
            else:
                axes[1, 0].text(0.5, 0.5, 'Í∞êÏ†ï Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå', ha='center', va='center', 
                               transform=axes[1, 0].transAxes, fontsize=14)
                axes[1, 0].set_title('Í∞êÏ†ïÎ≥Ñ ÌïòÏúÑ Îã¥Î°† Î∂ÑÌè¨', fontsize=16, fontweight='bold')
            
            # 4. Îã¥Î°† Îã§ÏñëÏÑ± ÏßÄÏàò (ÏóîÌä∏Î°úÌîº Í∏∞Î∞ò)
            discourse_diversity = []
            mainstream_concentration = []
            
            for period in periods:
                result = comprehensive_results[period]
                
                # ÌÜ†ÌîΩ Î∂ÑÌè¨Ïùò ÏóîÌä∏Î°úÌîº Í≥ÑÏÇ∞ (Îã§ÏñëÏÑ± ÏßÄÏàò)
                if 'bertopic' in result and result['bertopic'].get('topic_sizes'):
                    topic_sizes = list(result['bertopic']['topic_sizes'].values())
                    if topic_sizes:
                        # Ï†ïÍ∑úÌôî
                        total_size = sum(topic_sizes)
                        if total_size > 0:
                            probabilities = [size / total_size for size in topic_sizes]
                            # ÏóîÌä∏Î°úÌîº Í≥ÑÏÇ∞
                            entropy = -sum(p * np.log(p + 1e-10) for p in probabilities if p > 0)
                            discourse_diversity.append(entropy)
                            
                            # Ï£ºÎ•ò Îã¥Î°† ÏßëÏ§ëÎèÑ (ÏÉÅÏúÑ 3Í∞ú ÌÜ†ÌîΩÏùò ÎπÑÏú®)
                            sorted_probs = sorted(probabilities, reverse=True)
                            mainstream_ratio = sum(sorted_probs[:3])
                            mainstream_concentration.append(mainstream_ratio)
                        else:
                            discourse_diversity.append(0)
                            mainstream_concentration.append(0)
                    else:
                        discourse_diversity.append(0)
                        mainstream_concentration.append(0)
                else:
                    discourse_diversity.append(0)
                    mainstream_concentration.append(0)
            
            # Ïù¥Ï§ë yÏ∂ï Í∑∏ÎûòÌîÑ
            ax2 = axes[1, 1].twinx()
            
            line1 = axes[1, 1].plot(periods, discourse_diversity, marker='o', linewidth=3, 
                                   color='#27AE60', markersize=8, alpha=0.8, label='Îã¥Î°† Îã§ÏñëÏÑ±')
            line2 = ax2.plot(periods, mainstream_concentration, marker='s', linewidth=3, 
                            color='#E74C3C', markersize=8, alpha=0.8, label='Ï£ºÎ•ò ÏßëÏ§ëÎèÑ')
            
            axes[1, 1].set_title('Îã¥Î°† Îã§ÏñëÏÑ± vs Ï£ºÎ•ò ÏßëÏ§ëÎèÑ\n(Ïñ∏Î°† ÌîÑÎ†àÏûÑÏùò ÌïúÍ≥Ñ ÏßÄÏ†ê)', fontsize=16, fontweight='bold')
            axes[1, 1].set_ylabel('Îã§ÏñëÏÑ± ÏßÄÏàò (ÏóîÌä∏Î°úÌîº)', fontsize=14, color='#27AE60')
            ax2.set_ylabel('Ï£ºÎ•ò ÏßëÏ§ëÎèÑ', fontsize=14, color='#E74C3C')
            axes[1, 1].tick_params(axis='x', rotation=45)
            axes[1, 1].tick_params(axis='y', labelcolor='#27AE60')
            ax2.tick_params(axis='y', labelcolor='#E74C3C')
            axes[1, 1].grid(True, alpha=0.3)
            
            # Î≤îÎ°Ä ÌÜµÌï©
            lines = line1 + line2
            labels = [l.get_label() for l in lines]
            axes[1, 1].legend(lines, labels, loc='upper left')
            
            # Îã§ÏñëÏÑ±Ïù¥ ÎÜíÏùÄ Íµ¨Í∞Ñ ÌïòÏù¥ÎùºÏù¥Ìä∏
            if discourse_diversity:
                high_diversity_threshold = np.mean(discourse_diversity) + np.std(discourse_diversity)
                for i, diversity in enumerate(discourse_diversity):
                    if diversity > high_diversity_threshold:
                        axes[1, 1].axvspan(i-0.4, i+0.4, alpha=0.2, color='green', 
                                          label='Í≥†Îã§ÏñëÏÑ±' if i == 0 else "")
            
            plt.tight_layout()
            
            # ÌååÏùº Ï†ÄÏû•
            filename = f"{target_name}_hidden_discourse_analysis.png"
            filepath = os.path.join(self.output_dir, filename)
            
            # ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
            os.makedirs(os.path.dirname(filepath), exist_ok=True)
            
            plt.savefig(filepath, dpi=self.config.VISUALIZATION['dpi'], 
                       bbox_inches='tight', facecolor='white')
            plt.close()
            
            self.logger.info(f"‚úÖ Ïà®Í≤®ÏßÑ ÌïòÏúÑ Îã¥Î°† Î∞úÍµ¥ Î∂ÑÏÑù ÏãúÍ∞ÅÌôî ÏôÑÎ£å: {filepath}")
            return filepath
            
        except Exception as e:
            self.logger.error(f"‚ùå Ïà®Í≤®ÏßÑ ÌïòÏúÑ Îã¥Î°† Î∞úÍµ¥ Î∂ÑÏÑù ÏãúÍ∞ÅÌôî Ïã§Ìå®: {str(e)}")
            raise 